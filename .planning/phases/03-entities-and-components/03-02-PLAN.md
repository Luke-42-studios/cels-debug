---
phase: 03-entities-and-components
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tools/cels-debug/src/scroll.h
  - tools/cels-debug/src/scroll.c
  - tools/cels-debug/src/split_panel.h
  - tools/cels-debug/src/split_panel.c
  - tools/cels-debug/src/json_render.h
  - tools/cels-debug/src/json_render.c
  - tools/cels-debug/src/tree_view.h
  - tools/cels-debug/src/tree_view.c
  - tools/cels-debug/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Scroll state tracks cursor and scroll_offset for any list, clamping correctly at boundaries"
    - "Split panel creates two side-by-side ncurses windows with 40/60 split and focus switching"
    - "JSON renderer recursively displays arbitrary yyjson values with indentation and color"
    - "Tree view flattens entity tree into visible array respecting expand/collapse and anonymous filter"
  artifacts:
    - path: "tools/cels-debug/src/scroll.h"
      provides: "scroll_state_t type, scroll_move(), scroll_ensure_visible(), scroll_reset()"
      contains: "scroll_state_t"
    - path: "tools/cels-debug/src/scroll.c"
      provides: "Scroll state implementation with clamping"
      contains: "scroll_ensure_visible"
    - path: "tools/cels-debug/src/split_panel.h"
      provides: "split_panel_t type, create/destroy/resize/draw_borders/refresh"
      contains: "split_panel_t"
    - path: "tools/cels-debug/src/split_panel.c"
      provides: "Split panel window lifecycle and border rendering"
      contains: "split_panel_create"
    - path: "tools/cels-debug/src/json_render.h"
      provides: "json_render_value() recursive renderer"
      contains: "json_render_value"
    - path: "tools/cels-debug/src/json_render.c"
      provides: "Handles obj, arr, str, num, bool, null with color pairs and indentation"
      contains: "json_render_value"
    - path: "tools/cels-debug/src/tree_view.h"
      provides: "tree_view_t type, rebuild_visible(), tree_view_toggle_expand()"
      contains: "tree_view_t"
    - path: "tools/cels-debug/src/tree_view.c"
      provides: "DFS flattening, anonymous filter, expand/collapse, tree line rendering"
      contains: "tree_view_rebuild_visible"
  key_links:
    - from: "tools/cels-debug/src/tree_view.h"
      to: "tools/cels-debug/src/scroll.h"
      via: "tree_view_t embeds scroll_state_t"
      pattern: "scroll_state_t"
    - from: "tools/cels-debug/src/split_panel.c"
      to: "ncurses newwin/delwin"
      via: "window lifecycle for left/right panels"
      pattern: "newwin"
---

<objective>
Create four reusable UI utility modules: scroll state management, split-panel layout, recursive JSON renderer, and entity tree view with virtual scrolling.

Purpose: These modules are consumed by both the Entities and Components tabs (Plans 03-04) and will be reused by future phases (Systems tab needs scroll+split_panel). Building them as standalone modules prevents code duplication and keeps tab implementations focused.
Output: 8 new source files (4 .h + 4 .c) and updated CMakeLists.txt.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-RESEARCH.md

@tools/cels-debug/src/tui.h
@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/tab_system.h
@tools/cels-debug/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scroll, split_panel, and json_render modules</name>
  <files>
    tools/cels-debug/src/scroll.h
    tools/cels-debug/src/scroll.c
    tools/cels-debug/src/split_panel.h
    tools/cels-debug/src/split_panel.c
    tools/cels-debug/src/json_render.h
    tools/cels-debug/src/json_render.c
  </files>
  <action>
  **scroll.h / scroll.c -- Generic scroll state for any list**

  ```c
  typedef struct scroll_state {
      int total_items;    /* Total number of items in the list */
      int visible_rows;   /* Number of rows visible in the window */
      int cursor;         /* Currently selected item index [0..total_items-1] */
      int scroll_offset;  /* First visible item index */
  } scroll_state_t;
  ```

  Functions:
  - `void scroll_reset(scroll_state_t *s)` -- Set all fields to 0.
  - `void scroll_ensure_visible(scroll_state_t *s)` -- Adjust scroll_offset so cursor is within the visible range. Clamp scroll_offset to [0, max(0, total_items - visible_rows)].
  - `void scroll_move(scroll_state_t *s, int delta)` -- Move cursor by delta, clamp to [0, total_items-1], then call scroll_ensure_visible.
  - `void scroll_page(scroll_state_t *s, int direction)` -- Move by +/- visible_rows (Page Up/Page Down), clamp, ensure visible.
  - `void scroll_to_top(scroll_state_t *s)` -- Set cursor=0, scroll_offset=0.
  - `void scroll_to_bottom(scroll_state_t *s)` -- Set cursor=total_items-1, ensure visible.

  Edge case: if total_items <= 0, all operations are no-ops (cursor stays at 0).

  **split_panel.h / split_panel.c -- Two-panel layout with focus**

  ```c
  typedef struct split_panel {
      WINDOW *left;
      WINDOW *right;
      int left_width;      /* Columns for left panel */
      int right_width;     /* Columns for right panel */
      int height;          /* Rows available */
      int start_row;       /* Starting row on screen */
      int focus;           /* 0 = left, 1 = right */
  } split_panel_t;
  ```

  Functions:
  - `void split_panel_create(split_panel_t *sp, int height, int width, int start_row)` -- Calculate left_width as width*40/100, right_width as width-left_width. Create left and right windows with newwin(). Set focus=0. Enable keypad on both windows.
  - `void split_panel_destroy(split_panel_t *sp)` -- delwin both windows, set pointers to NULL.
  - `void split_panel_resize(split_panel_t *sp, int height, int width, int start_row)` -- Destroy then recreate with new dimensions.
  - `void split_panel_draw_borders(split_panel_t *sp, const char *left_title, const char *right_title)` -- Draw box() on each window. Active panel border with A_BOLD, inactive with A_DIM (using CP_PANEL_ACTIVE / CP_PANEL_INACTIVE from tui.h). Draw titles inside the top border: `mvwprintw(win, 0, 2, " %s ", title)`.
  - `void split_panel_refresh(split_panel_t *sp)` -- Call wnoutrefresh() on both windows. (Caller calls doupdate() later -- but actually tui_render already calls doupdate, so this is just the wnoutrefresh calls.)
  - `WINDOW *split_panel_focused(split_panel_t *sp)` -- Return the focused window (left or right).
  - `bool split_panel_handle_focus(split_panel_t *sp, int ch)` -- If ch is KEY_LEFT, set focus=0, return true. If KEY_RIGHT, set focus=1, return true. Otherwise return false.

  Include `<ncurses.h>` and `<stdbool.h>` in split_panel.h. Include `"tui.h"` in split_panel.c for CP_PANEL_ACTIVE/CP_PANEL_INACTIVE defines.

  **json_render.h / json_render.c -- Recursive JSON value renderer for ncurses**

  Function:
  ```c
  int json_render_value(WINDOW *win, yyjson_val *val, int row, int col, int max_row, int col_width);
  ```
  Returns: number of rows consumed.

  Implementation (recursive):
  - If row >= max_row, return 0 (out of visible area).
  - `yyjson_is_null(val)`: print "null" in A_DIM at (row, col). Return 1.
  - `yyjson_is_bool(val)`: print "true"/"false" in CP_JSON_NUMBER at (row, col). Return 1.
  - `yyjson_is_int(val)` or `yyjson_is_real(val)`: print numeric value in CP_JSON_NUMBER. Use `%lld` for int, `%.4g` for real. Return 1.
  - `yyjson_is_str(val)`: print `"value"` in CP_JSON_STRING, truncated to col_width - col - 2. Return 1.
  - `yyjson_is_obj(val)`: iterate with yyjson_obj_foreach. For each key-value:
    - Print key name in CP_JSON_KEY at (row+rows_used, col), followed by ": ".
    - If child is obj or arr: increment rows_used, recurse at indent col+2.
    - If child is simple: render on same line at current cursor x position.
    - Accumulate rows_used. Return rows_used.
  - `yyjson_is_arr(val)`: iterate with yyjson_arr_foreach. For each element:
    - Print `[idx]:` at (row+rows_used, col).
    - If element is obj or arr: increment rows_used, recurse at indent col+2.
    - If element is simple: render on same line.
    - Accumulate rows_used. Return rows_used.

  Also add a convenience function for rendering component groups:
  ```c
  int json_render_component(WINDOW *win, const char *comp_name, yyjson_val *comp_val,
                            int row, int col, int max_row, int col_width, bool expanded);
  ```
  This renders the component header (comp_name in CP_COMPONENT_HEADER with A_BOLD, plus expand/collapse indicator). If expanded and comp_val is not null, calls json_render_value for the component's value. Returns total rows consumed.

  Include `<yyjson.h>`, `<ncurses.h>`, `<stdbool.h>` in json_render.h. Include `"tui.h"` in json_render.c for color pair defines.
  </action>
  <verify>
  After adding all 6 files to CMakeLists.txt (see Task 2), project compiles: `cmake --build build 2>&1 | tail -5`
  </verify>
  <done>scroll.h/c provides reusable list scrolling. split_panel.h/c creates/destroys/resizes two ncurses windows with focus management. json_render.h/c recursively renders yyjson values with syntax coloring.</done>
</task>

<task type="auto">
  <name>Task 2: Create tree_view module and update CMakeLists.txt</name>
  <files>
    tools/cels-debug/src/tree_view.h
    tools/cels-debug/src/tree_view.c
    tools/cels-debug/CMakeLists.txt
  </files>
  <action>
  **tree_view.h / tree_view.c -- Entity tree with virtual scrolling**

  ```c
  typedef struct tree_view {
      entity_node_t **visible;   /* Flattened visible nodes (pointers into entity_list) */
      int visible_count;
      scroll_state_t scroll;     /* Scroll state for the visible list */
      bool show_anonymous;       /* Toggle for 'f' key, default false */
  } tree_view_t;
  ```

  NOTE: tree_view does NOT own the entity_node_t data. It holds pointers into the entity_list_t owned by app_state. When entity_list is replaced on the next poll, the tree_view's visible[] becomes stale and must be rebuilt.

  Functions:

  - `void tree_view_init(tree_view_t *tv)` -- Zero out all fields. visible=NULL, visible_count=0, show_anonymous=false.

  - `void tree_view_fini(tree_view_t *tv)` -- Free visible[] array (not the nodes themselves). Reset all fields.

  - `void tree_view_rebuild_visible(tree_view_t *tv, entity_list_t *list)` -- Rebuild the flattened visible array from the entity tree.
    Algorithm:
    1. Free old visible[] if any.
    2. Count maximum possible visible (list->count).
    3. Allocate visible[] array of that size.
    4. DFS traversal starting from each root in list->roots[]:
       - For each node: if is_anonymous && !show_anonymous, skip (and skip subtree).
       - Add node to visible[visible_count++].
       - If node->expanded and has children, recurse into children (already sorted by creation order from the parse).
    5. Update scroll.total_items = visible_count.
    6. Preserve cursor: try to keep the same entity selected after rebuild. If the previously-selected entity (by id) is still in the new visible list, set cursor to its new index. Otherwise clamp cursor to valid range.

  - `void tree_view_toggle_expand(tree_view_t *tv, entity_list_t *list)` -- Toggle expanded on the node at current cursor position. Then call tree_view_rebuild_visible. Preserve cursor on the toggled node.

  - `void tree_view_toggle_anonymous(tree_view_t *tv, entity_list_t *list)` -- Flip show_anonymous, rebuild visible, preserve cursor.

  - `entity_node_t *tree_view_selected(tree_view_t *tv)` -- Return visible[scroll.cursor] or NULL if no items.

  - `void tree_view_render(tree_view_t *tv, WINDOW *win)` -- Render the visible portion of the tree into the window.
    1. Get window dimensions: `int rows = getmaxy(win) - 2;` (subtract 2 for border). `int cols = getmaxx(win) - 2;`
    2. Update scroll.visible_rows = rows.
    3. For each visible row (from scroll.scroll_offset to scroll.scroll_offset + rows):
       - Get node = visible[item_idx].
       - Determine if this is the cursor row (item_idx == scroll.cursor). If so, apply A_REVERSE.
       - Render tree indentation using Unicode box drawing characters:
         For depth levels 0 to node->depth-1, draw either vertical continuation line or spaces depending on whether the ancestor at that depth has more siblings below.
         At the node's own depth level: draw branch (TREE_BRANCH + TREE_HORIZ*2 + " ") if not last child, or corner (TREE_LAST + TREE_HORIZ*2 + " ") if last child.
         Each depth level = 4 columns.
       - If node has children, show expand indicator: "v " if expanded, "> " if collapsed.
       - Print entity name (or "#<id>" for anonymous in A_DIM).
       - Right-align component names inline: show first 3 component names comma-separated in A_DIM, plus "+N more" if more than 3. Truncate to fit panel width.
       - Clear A_REVERSE if cursor row.

  Helper for tree rendering -- determining if a node is the last child of its parent:
  ```c
  static bool node_is_last_child(entity_node_t *node) {
      if (!node->parent) return true;  /* root nodes: treat as last */
      return node->parent->children[node->parent->child_count - 1] == node;
  }
  ```

  Helper for determining if ancestor at a given depth has more siblings below (needed for drawing the vertical continuation line vs blank space):
  ```c
  static bool ancestor_has_next_sibling(entity_node_t *node, int target_depth) {
      /* Walk up from node to find ancestor at target_depth */
      entity_node_t *ancestor = node;
      while (ancestor && ancestor->depth > target_depth) {
          ancestor = ancestor->parent;
      }
      if (!ancestor) return false;
      return !node_is_last_child(ancestor);
  }
  ```

  Define UTF-8 box drawing character macros in tree_view.c (or tree_view.h):
  ```c
  #define TREE_VERT    "\xe2\x94\x82"   /* vertical line */
  #define TREE_BRANCH  "\xe2\x94\x9c"   /* branch (has sibling below) */
  #define TREE_LAST    "\xe2\x94\x94"   /* last child corner */
  #define TREE_HORIZ   "\xe2\x94\x80"   /* horizontal line */
  ```

  **CMakeLists.txt changes:**

  Add all new source files to the `add_executable(cels-debug ...)` list:
  ```
  src/scroll.c
  src/split_panel.c
  src/json_render.c
  src/tree_view.c
  ```

  Place them after the existing source files but before the tabs/ files for organization.
  </action>
  <verify>
  Build compiles: `cd /home/cachy/workspaces/libs/cels/tools/cels-debug && cmake -B build -DCMAKE_BUILD_TYPE=Debug && cmake --build build 2>&1 | tail -10`
  No warnings on new files.
  Verify all 4 new .c files appear in CMakeLists.txt: `grep -c 'scroll\|split_panel\|json_render\|tree_view' CMakeLists.txt` should return 4.
  </verify>
  <done>tree_view module builds entity tree into flattened visible array with DFS, supports expand/collapse and anonymous filtering, renders with Unicode box drawing. All 4 utility modules compile and are linked. CMakeLists.txt includes all 8 new source files.</done>
</task>

</tasks>

<verification>
1. `cmake -B build && cmake --build build` succeeds with no warnings on new code
2. scroll.h declares scroll_state_t and all scroll functions
3. split_panel.h declares split_panel_t with create/destroy/resize/refresh
4. json_render.h declares json_render_value and json_render_component
5. tree_view.h declares tree_view_t with rebuild_visible, toggle_expand, toggle_anonymous, render
6. CMakeLists.txt lists all 4 new .c files in add_executable
7. All modules use established patterns: ncurses wnoutrefresh (not wrefresh), CP_* color pairs from tui.h
</verification>

<success_criteria>
Four reusable UI modules compile and are ready for consumption by the Entities tab (Plan 03) and Components tab (Plan 04). Each module is self-contained with clear API boundaries. The tree_view module handles the complex entity tree flattening with proper Unicode rendering.
</success_criteria>

<output>
After completion, create `.planning/phases/03-entities-and-components/03-02-SUMMARY.md`
</output>
