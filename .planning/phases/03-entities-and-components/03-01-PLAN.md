---
phase: 03-entities-and-components
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tools/cels-debug/src/data_model.h
  - tools/cels-debug/src/data_model.c
  - tools/cels-debug/src/json_parser.h
  - tools/cels-debug/src/json_parser.c
  - tools/cels-debug/src/tui.h
  - tools/cels-debug/src/tui.c
  - tools/cels-debug/src/main.c
autonomous: true

must_haves:
  truths:
    - "Entity list data is fetched from /query endpoint when Entities tab is active"
    - "Selected entity detail is fetched from /entity/<path> endpoint when an entity is selected"
    - "Component registry is fetched from /components endpoint when Components tab is active"
    - "Data model structs hold parsed entity, detail, and component registry data"
  artifacts:
    - path: "tools/cels-debug/src/data_model.h"
      provides: "entity_node_t, entity_detail_t, component_info_t, entity_list_t, component_registry_t types"
      contains: "entity_node_t"
    - path: "tools/cels-debug/src/data_model.c"
      provides: "Allocation and free functions for all new data types"
      contains: "entity_list_free"
    - path: "tools/cels-debug/src/json_parser.h"
      provides: "json_parse_entity_list, json_parse_entity_detail, json_parse_component_registry declarations"
      exports: ["json_parse_entity_list", "json_parse_entity_detail", "json_parse_component_registry"]
    - path: "tools/cels-debug/src/json_parser.c"
      provides: "Parse implementations for /query, /entity, /components responses"
      contains: "json_parse_entity_list"
    - path: "tools/cels-debug/src/main.c"
      provides: "Conditional polling for ENDPOINT_QUERY, ENDPOINT_ENTITY, ENDPOINT_COMPONENTS"
      contains: "ENDPOINT_QUERY"
  key_links:
    - from: "tools/cels-debug/src/main.c"
      to: "json_parse_entity_list"
      via: "conditional poll when ENDPOINT_QUERY bit set"
      pattern: "needed & ENDPOINT_QUERY"
    - from: "tools/cels-debug/src/main.c"
      to: "json_parse_entity_detail"
      via: "conditional poll when entity selected and ENDPOINT_ENTITY bit set"
      pattern: "needed & ENDPOINT_ENTITY"
    - from: "tools/cels-debug/src/json_parser.c"
      to: "data_model.h types"
      via: "parse functions return data model structs"
      pattern: "entity_list_t"
---

<objective>
Extend the data pipeline to fetch, parse, and store entity list, entity detail, and component registry data from flecs REST API endpoints.

Purpose: Provide the data foundation that the Entities and Components tabs will consume. Without this, the tabs have no data to display.
Output: Extended data_model with entity/component types, three new JSON parsers, and main loop conditional polling for all Phase 03 endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-CONTEXT.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-RESEARCH.md

@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/data_model.c
@tools/cels-debug/src/json_parser.h
@tools/cels-debug/src/json_parser.c
@tools/cels-debug/src/main.c
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/tui.c
@tools/cels-debug/src/http_client.h
@tools/cels-debug/src/tab_system.h
@tools/cels-debug/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend data model with entity and component types</name>
  <files>
    tools/cels-debug/src/data_model.h
    tools/cels-debug/src/data_model.c
  </files>
  <action>
  Add the following types to data_model.h (AFTER the existing world_snapshot_t):

  1. `entity_node_t` struct:
     - `char *name` (entity leaf name, NULL for anonymous)
     - `char *full_path` (slash-separated for REST URL, e.g., "Sun/Earth")
     - `uint64_t id` (numeric entity ID)
     - `char **component_names` + `int component_count` (from lightweight list poll)
     - `char **tags` + `int tag_count`
     - `struct entity_node_t *parent` (tree link)
     - `struct entity_node_t **children` + `int child_count` + `int child_capacity`
     - `bool expanded` (UI collapse state, default true for root nodes)
     - `bool is_anonymous` (no name, only numeric ID)
     - `int depth` (nesting level for indentation)

  2. `entity_list_t` struct (owns all entity nodes from one poll):
     - `entity_node_t **nodes` + `int count` (flat ownership array of all nodes)
     - `entity_node_t **roots` + `int root_count` (top-level nodes, pointers into nodes[])

  3. `entity_detail_t` struct (selected entity component data):
     - `char *path` (entity path for REST lookup)
     - `uint64_t id`
     - `yyjson_doc *doc` (parsed JSON, owns all values -- include yyjson.h)
     - `yyjson_val *components` (pointer into doc: "components" object)
     - `yyjson_val *tags` (pointer into doc: "tags" array)
     - `yyjson_val *pairs` (pointer into doc: "pairs" object)

  4. `component_info_t` struct:
     - `char *name`
     - `int entity_count`
     - `int size` (type size in bytes, 0 if no type_info)
     - `bool has_type_info`

  5. `component_registry_t` struct:
     - `component_info_t *components` + `int count`

  Add corresponding create/free functions in data_model.c:
  - `entity_node_t *entity_node_create(void)` -- calloc, set expanded=true
  - `void entity_node_free(entity_node_t *node)` -- free name, full_path, component_names[], tags[], children[] (NOT recursive -- entity_list_free handles that)
  - `entity_list_t *entity_list_create(void)` -- calloc
  - `void entity_list_free(entity_list_t *list)` -- free each node via entity_node_free, then free nodes[], roots[], then the list itself
  - `entity_detail_t *entity_detail_create(void)` -- calloc
  - `void entity_detail_free(entity_detail_t *detail)` -- free path, yyjson_doc_free(doc), free struct
  - `component_registry_t *component_registry_create(void)` -- calloc
  - `void component_registry_free(component_registry_t *reg)` -- free each component_info_t name, free components[], free struct

  Include `<stdbool.h>` and `<yyjson.h>` in data_model.h (yyjson.h needed for entity_detail_t).

  IMPORTANT: entity_node_t children array uses a dynamic capacity pattern. Add a helper:
  - `void entity_node_add_child(entity_node_t *parent, entity_node_t *child)` -- grows children[] by doubling capacity, sets child->parent and child->depth.
  </action>
  <verify>
  The project compiles: `cd /home/cachy/workspaces/libs/cels/tools/cels-debug && cmake -B build -DCMAKE_BUILD_TYPE=Debug && cmake --build build 2>&1 | tail -5`
  No compiler warnings related to the new types.
  </verify>
  <done>data_model.h declares all 5 new types. data_model.c implements create/free for each. Project compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add JSON parsers for entity list, entity detail, and component registry</name>
  <files>
    tools/cels-debug/src/json_parser.h
    tools/cels-debug/src/json_parser.c
  </files>
  <action>
  Add three new parse functions to json_parser.h and implement them in json_parser.c.

  **1. `entity_list_t *json_parse_entity_list(const char *json, size_t len)`**

  Parses the `/query?expr=...&entity_id=true&values=false&table=true` response.

  Response format (see 03-RESEARCH.md "Endpoint 1"):
  ```json
  {"results": [{"parent": "Sun", "name": "Earth", "id": 775, "tags": [...], "components": {"Position": null, ...}}]}
  ```

  Algorithm:
  1. Parse JSON with yyjson_read. Get root->"results" array.
  2. First pass: iterate results, create entity_node_t for each. Extract name (strdup), id, is_anonymous (name missing/empty). Extract component_names from "components" object keys. Extract tags from "tags" array.
  3. Build full_path: if "parent" field exists, full_path = parent + "/" + name (using "/" separator for REST URLs). If no parent, full_path = name. For anonymous entities, full_path = string of the numeric id.
  4. CRITICAL PATH CONVERSION: The "parent" field from flecs uses "." as separator (e.g., "Earth.shipyard"). Replace all "." with "/" when building full_path for REST API URLs. Store the slash-separated version.
  5. Build parent-child tree: create a temporary hash map (simple linear scan is fine for <5K entities) mapping full_path -> entity_node_t*. For each node, look up its parent's full_path in the map. If found, call entity_node_add_child(parent_node, node). If not found (parent entity not in results, possibly filtered), treat as root.
  6. Collect root nodes (those with parent==NULL) into entity_list->roots[].
  7. yyjson_doc_free(doc) is safe because all strings were strdup'd.
  8. Return the entity_list_t. Caller frees via entity_list_free().

  For the parent path lookup (step 5), construct the parent's full_path by taking the "parent" field and replacing "." with "/". Then scan the nodes array for a matching full_path. O(n^2) is acceptable for <5K entities and simpler than a hash table.

  **2. `entity_detail_t *json_parse_entity_detail(const char *json, size_t len)`**

  Parses the `/entity/<path>?entity_id=true&try=true` response.

  Response format (see 03-RESEARCH.md "Endpoint 2"):
  ```json
  {"parent": "Sun", "name": "Earth", "id": 775, "tags": [...], "pairs": {...}, "components": {"Mass": {"value": ...}, ...}}
  ```

  Algorithm:
  1. Parse with yyjson_read. DO NOT FREE the doc -- entity_detail_t owns it.
  2. Create entity_detail_t. Store doc pointer.
  3. Extract "id" -> detail->id.
  4. Build path from "parent" + "name" (same dot-to-slash conversion). Store in detail->path (strdup).
  5. Store pointers into the doc for "components", "tags", "pairs" objects. These yyjson_val* pointers are valid as long as doc lives.
  6. Return detail. Caller frees via entity_detail_free() which calls yyjson_doc_free.

  **3. `component_registry_t *json_parse_component_registry(const char *json, size_t len)`**

  Parses the `/components` response.

  Response format (see 03-RESEARCH.md "Endpoint 3"):
  ```json
  [{"name": "Position", "entity_count": 150, "type": {"size": 8, ...}}, ...]
  ```

  Algorithm:
  1. Parse with yyjson_read. Root is a JSON array (NOT object).
  2. Iterate array elements. For each:
     - Extract "name" (strdup), "entity_count" (int), "type" object presence (has_type_info).
     - If "type" exists and is object, extract "size".
  3. yyjson_doc_free(doc) -- all strings strdup'd.
  4. Return component_registry_t. Caller frees via component_registry_free().

  Include data_model.h in json_parser.h if not already (it already is). Add the 3 new function declarations.
  </action>
  <verify>
  The project compiles: `cd /home/cachy/workspaces/libs/cels/tools/cels-debug && cmake --build build 2>&1 | tail -5`
  No compiler warnings on the new functions.
  </verify>
  <done>Three parse functions compile and follow the patterns from 03-RESEARCH.md. json_parse_entity_list builds parent-child tree. json_parse_entity_detail preserves yyjson_doc for zero-copy value access. json_parse_component_registry handles the root-is-array format.</done>
</task>

<task type="auto">
  <name>Task 3: Extend app_state and main loop with conditional endpoint polling</name>
  <files>
    tools/cels-debug/src/tui.h
    tools/cels-debug/src/tui.c
    tools/cels-debug/src/main.c
  </files>
  <action>
  **tui.h changes:**

  1. Extend app_state_t with new fields:
     ```c
     typedef struct app_state {
         world_snapshot_t      *snapshot;
         connection_state_t     conn_state;
         /* Phase 03: entity and component data */
         entity_list_t         *entity_list;      /* from /query */
         entity_detail_t       *entity_detail;     /* from /entity/<path> */
         component_registry_t  *component_registry; /* from /components */
         char                  *selected_entity_path; /* slash-separated path of selected entity, or NULL */
         char                  *footer_message;    /* transient message (e.g., "Entity X removed") */
         int64_t                footer_message_expire; /* timestamp when message should clear */
     } app_state_t;
     ```

  2. Add new color pair defines (after CP_TAB_INACTIVE):
     ```c
     #define CP_TREE_LINE          7
     #define CP_ENTITY_NAME        8
     #define CP_COMPONENT_HEADER   9
     #define CP_JSON_KEY          10
     #define CP_JSON_STRING       11
     #define CP_JSON_NUMBER       12
     #define CP_PANEL_ACTIVE      13
     #define CP_PANEL_INACTIVE    14
     #define CP_CURSOR            15
     ```

  Include data_model.h at the top of tui.h (it already includes data_model.h, but verify entity_list_t etc. are available after the data_model.h changes from Task 1).

  **tui.c changes:**

  1. Add `#include <locale.h>` at the top.
  2. In `tui_init()`, add `setlocale(LC_ALL, "");` as the FIRST line of the function, BEFORE signal handlers. This is required for Unicode box drawing characters to render correctly with ncursesw.
  3. In the color init block, add init_pair calls for the new color pairs:
     ```c
     init_pair(CP_TREE_LINE,        COLOR_WHITE,  -1);  /* dim applied at render time */
     init_pair(CP_ENTITY_NAME,      COLOR_WHITE,  -1);
     init_pair(CP_COMPONENT_HEADER, COLOR_CYAN,   -1);
     init_pair(CP_JSON_KEY,         COLOR_CYAN,   -1);
     init_pair(CP_JSON_STRING,      COLOR_GREEN,  -1);
     init_pair(CP_JSON_NUMBER,      COLOR_YELLOW, -1);
     init_pair(CP_PANEL_ACTIVE,     COLOR_WHITE,  -1);
     init_pair(CP_PANEL_INACTIVE,   COLOR_WHITE,  -1);  /* dim applied at render time */
     init_pair(CP_CURSOR,           COLOR_BLACK,  COLOR_WHITE);
     ```
  4. In `tui_render()`, after drawing the footer help text, add footer_message rendering:
     If `state->footer_message` is not NULL and current time < `state->footer_message_expire`, display the message right-aligned on the footer line in CP_RECONNECTING color (yellow).

  **main.c changes:**

  1. Add `#include <string.h>` if not already included (for strdup, strcmp).
  2. Replace the TODO comment at lines 98-99 with actual conditional polling. Inside the existing `if (now - last_poll >= POLL_INTERVAL_MS)` block, AFTER the existing stats/world poll and parse, add:

     ```c
     /* Poll entity list if active tab needs it */
     if ((needed & ENDPOINT_QUERY) && app_state.conn_state == CONN_CONNECTED) {
         static const char *entity_list_url =
             "http://localhost:27750/query"
             "?expr=!ChildOf(self%7Cup%2Cflecs)%2C!Module(self%7Cup)"
             "&entity_id=true&values=false&table=true&try=true";
         http_response_t qresp = http_get(curl, entity_list_url);
         if (qresp.status == 200 && qresp.body.data) {
             entity_list_t *new_list =
                 json_parse_entity_list(qresp.body.data, qresp.body.size);
             if (new_list) {
                 entity_list_free(app_state.entity_list);
                 app_state.entity_list = new_list;
             }
         }
         http_response_free(&qresp);
     }

     /* Poll selected entity detail if an entity is selected */
     if ((needed & ENDPOINT_ENTITY) && app_state.selected_entity_path &&
         app_state.conn_state == CONN_CONNECTED) {
         char entity_url[512];
         snprintf(entity_url, sizeof(entity_url),
             "http://localhost:27750/entity/%s?entity_id=true&try=true",
             app_state.selected_entity_path);
         http_response_t eresp = http_get(curl, entity_url);
         if (eresp.status == 200 && eresp.body.data) {
             entity_detail_t *new_detail =
                 json_parse_entity_detail(eresp.body.data, eresp.body.size);
             if (new_detail) {
                 entity_detail_free(app_state.entity_detail);
                 app_state.entity_detail = new_detail;
             }
         } else if (eresp.status == 404 || eresp.status == -1) {
             /* Entity was deleted -- clear detail and notify */
             entity_detail_free(app_state.entity_detail);
             app_state.entity_detail = NULL;
             /* Set footer notification */
             free(app_state.footer_message);
             app_state.footer_message = strdup("Selected entity removed");
             app_state.footer_message_expire = now + 3000; /* 3 seconds */
             free(app_state.selected_entity_path);
             app_state.selected_entity_path = NULL;
         }
         http_response_free(&eresp);
     }

     /* Poll component registry if active tab needs it */
     if ((needed & ENDPOINT_COMPONENTS) && app_state.conn_state == CONN_CONNECTED) {
         http_response_t cresp = http_get(curl,
             "http://localhost:27750/components");
         if (cresp.status == 200 && cresp.body.data) {
             component_registry_t *new_reg =
                 json_parse_component_registry(cresp.body.data, cresp.body.size);
             if (new_reg) {
                 component_registry_free(app_state.component_registry);
                 app_state.component_registry = new_reg;
             }
         }
         http_response_free(&cresp);
     }

     /* Expire footer message */
     if (app_state.footer_message && now >= app_state.footer_message_expire) {
         free(app_state.footer_message);
         app_state.footer_message = NULL;
     }
     ```

  3. In cleanup at the end of main(), add frees for the new fields:
     ```c
     entity_list_free(app_state.entity_list);
     entity_detail_free(app_state.entity_detail);
     component_registry_free(app_state.component_registry);
     free(app_state.selected_entity_path);
     free(app_state.footer_message);
     ```

  4. Also update the Entities tab endpoint in tab_system.c: change its required_endpoints from `ENDPOINT_QUERY` to `ENDPOINT_QUERY | ENDPOINT_ENTITY` since the Entities tab needs both the list and the detail endpoint. (Read tab_system.c, find the "Entities" entry in tab_defs, update the bitmask.)

  IMPORTANT: Do NOT change the tab_defs function pointers yet (keep placeholder for Entities and Components tabs). Only change the endpoint bitmask for the Entities tab entry.
  </action>
  <verify>
  Build compiles: `cd /home/cachy/workspaces/libs/cels/tools/cels-debug && cmake --build build 2>&1 | tail -10`
  Run and verify no crash when switching to Entities/Components tabs (they still show placeholder): `cd /home/cachy/workspaces/libs/cels && ./run.sh debug` (if available) or just verify build succeeds.
  </verify>
  <done>app_state_t contains entity_list, entity_detail, component_registry, and selected_entity_path fields. main.c polls all 3 endpoints conditionally based on active tab's required_endpoints bitmask. Color pairs 7-15 are initialized. setlocale(LC_ALL, "") is called before initscr(). Footer message system works for transient notifications.</done>
</task>

</tasks>

<verification>
1. `cmake --build build` succeeds with no warnings on new code
2. All new data types are declared in data_model.h and have create/free functions in data_model.c
3. All three JSON parsers are declared in json_parser.h and implemented in json_parser.c
4. main.c polling block includes conditional fetches gated on endpoint bitmask bits
5. app_state_t has entity_list, entity_detail, component_registry, selected_entity_path fields
6. CP_TREE_LINE through CP_CURSOR (7-15) are defined in tui.h and initialized in tui.c
7. setlocale(LC_ALL, "") is called in tui_init() before initscr()
</verification>

<success_criteria>
The data pipeline is complete: when the Entities or Components tab is active, the main loop fetches the appropriate endpoints, parses responses into typed structs, and stores them in app_state. All data types are properly allocated and freed. The UI modules (Plans 02-04) can consume this data without any further data_model or main.c changes.
</success_criteria>

<output>
After completion, create `.planning/phases/03-entities-and-components/03-01-SUMMARY.md`
</output>
