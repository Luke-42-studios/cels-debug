---
phase: 03-entities-and-components
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - tools/cels-debug/src/tabs/tab_components.h
  - tools/cels-debug/src/tabs/tab_components.c
  - tools/cels-debug/src/tab_system.c
  - tools/cels-debug/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Components tab shows a scrollable list of all registered component types with entity counts"
    - "Selecting a component type shows entities with that component in the right panel"
    - "j/k or arrow keys scroll the list, left/right arrows switch panel focus"
    - "Component types are sorted by name for easy browsing"
  artifacts:
    - path: "tools/cels-debug/src/tabs/tab_components.h"
      provides: "tab_components_init/fini/draw/input declarations"
      contains: "tab_components_init"
    - path: "tools/cels-debug/src/tabs/tab_components.c"
      provides: "Full Components tab implementation with split panel and drill-down"
      min_lines: 100
    - path: "tools/cels-debug/src/tab_system.c"
      provides: "Components tab wired into tab_defs array"
      contains: "tab_components_init"
  key_links:
    - from: "tools/cels-debug/src/tabs/tab_components.c"
      to: "app_state.component_registry"
      via: "reads component list for left panel"
      pattern: "component_registry"
    - from: "tools/cels-debug/src/tabs/tab_components.c"
      to: "app_state.entity_list"
      via: "filters entity_list for entities having selected component"
      pattern: "entity_list"
    - from: "tools/cels-debug/src/tab_system.c"
      to: "tab_components_init"
      via: "tab_defs[2] vtable entry"
      pattern: "tab_components"
---

<objective>
Implement the Components tab: a split-panel view listing all registered component types (left) with drill-down to entities having the selected component (right).

Purpose: Complements the Entities tab by giving a component-centric view. Users can see all component types in the ECS world, how many entities use each, and which entities have a specific component.
Output: Working Components tab replacing the placeholder, wired into the tab system.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-CONTEXT.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-RESEARCH.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-01-SUMMARY.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-02-SUMMARY.md
@tools/cels-debug/.planning/phases/03-entities-and-components/03-03-SUMMARY.md

@tools/cels-debug/src/tui.h
@tools/cels-debug/src/tab_system.h
@tools/cels-debug/src/tab_system.c
@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/split_panel.h
@tools/cels-debug/src/scroll.h
@tools/cels-debug/src/tabs/tab_entities.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement the Components tab</name>
  <files>
    tools/cels-debug/src/tabs/tab_components.h
    tools/cels-debug/src/tabs/tab_components.c
  </files>
  <action>
  **tab_components.h** -- Follow the same pattern as other tab headers:
  ```c
  #ifndef CELS_DEBUG_TAB_COMPONENTS_H
  #define CELS_DEBUG_TAB_COMPONENTS_H
  #include "../tab_system.h"
  void tab_components_init(tab_t *self);
  void tab_components_fini(tab_t *self);
  void tab_components_draw(const tab_t *self, WINDOW *win, const void *app_state);
  bool tab_components_input(tab_t *self, int ch, void *app_state);
  #endif
  ```

  **tab_components.c** -- Full implementation:

  Per-tab private state struct:
  ```c
  typedef struct components_state {
      split_panel_t panel;            /* Left/right split */
      scroll_state_t left_scroll;     /* Scroll for component type list */
      scroll_state_t right_scroll;    /* Scroll for entities with component */
      bool panel_created;
  } components_state_t;
  ```

  **tab_components_init:**
  1. Allocate components_state_t, store in self->state.
  2. Call scroll_reset on both scrolls.
  3. Set panel_created = false.

  **tab_components_fini:**
  1. If panel_created, call split_panel_destroy.
  2. Free the components_state_t.

  **tab_components_draw:**
  1. Cast app_state to app_state_t*.
  2. Get window dimensions from `win` (the passed content window). Lazy-create or resize split_panel as needed (same pattern as Entities tab).
  3. Erase both panels. Draw borders with titles "Components" (left) and "Entities" (right).

  **Left panel (component registry):**
  4. If state->component_registry is not NULL:
     - Set left_scroll.total_items = component_registry->count.
     - Set left_scroll.visible_rows = panel height - 2 (for border).
     - Render visible items from scroll_offset:
       For each visible row:
       - Get component_info_t at index scroll_offset + row.
       - If cursor row, apply A_REVERSE.
       - Print component name left-aligned.
       - Print entity_count right-aligned in A_DIM (e.g., "42 entities" or just the count).
       - If has_type_info, show size in bytes in parentheses.
       - Clear A_REVERSE.
  5. If component_registry is NULL, center "Waiting for data..." in left panel.

  **Right panel (entities with selected component):**
  6. Get the selected component: if left_scroll.cursor is valid, get component_info_t at that index.
  7. If a component is selected and state->entity_list is not NULL:
     - Filter entity_list to find entities that have the selected component name in their component_names array.
     - Build a temporary array of matching entity_node_t pointers (scan entity_list->nodes[], for each check if any component_names[i] matches the selected component name using strcmp).
     - Set right_scroll.total_items = match count.
     - Set right_scroll.visible_rows = panel height - 2.
     - Render visible matching entities:
       For each visible row:
       - If cursor row (right panel focused), apply A_REVERSE.
       - Print entity name (or "#<id>" for anonymous).
       - Print entity's full_path in A_DIM to the right (truncated to fit).
       - Clear A_REVERSE.
     - If no matches, show "No entities" centered.
  8. If no component selected, show "Select a component" centered.

  NOTE: The filtering is done fresh each draw call. For <5K entities and <500 components, this is fast enough (simple string comparison loop). No need to cache the filtered list.

  **Optimization:** Sorting the component list alphabetically by name makes it easier to browse. Sort the component_registry->components array by name on each draw if it changed (compare count or a generation counter). Use qsort with strcmp comparator. Since component_registry is replaced atomically on each poll, sorting on each draw is a clean approach. Alternatively, sort once after parsing in json_parse_component_registry. Prefer sorting in the tab draw (keeps parser simple, sort is O(n log n) on ~100 components = negligible).

  9. Call split_panel_refresh to wnoutrefresh both windows.

  Same pattern as Entities tab: draw into own windows, NOT the passed win.

  **tab_components_input:**
  1. Check focus switching: `if (split_panel_handle_focus(&cs->panel, ch)) return true;`
  2. If left panel focused:
     - KEY_UP/'k': scroll_move(&cs->left_scroll, -1), reset right_scroll cursor to 0.
     - KEY_DOWN/'j': scroll_move(&cs->left_scroll, +1), reset right_scroll cursor to 0.
     - KEY_PPAGE: scroll_page(&cs->left_scroll, -1).
     - KEY_NPAGE: scroll_page(&cs->left_scroll, +1).
     - 'g': scroll_to_top. 'G': scroll_to_bottom.
     Return true for handled keys.
  3. If right panel focused:
     - KEY_UP/'k': scroll_move(&cs->right_scroll, -1).
     - KEY_DOWN/'j': scroll_move(&cs->right_scroll, +1).
     Return true for handled keys.
  4. Return false for unhandled keys.

  **Required endpoints:** The Components tab needs both ENDPOINT_COMPONENTS (for the component registry) and ENDPOINT_QUERY (for the entity list used in filtering). Update the tab_defs bitmask accordingly in Task 2.

  Include: `"../tui.h"`, `"../split_panel.h"`, `"../scroll.h"`, `"../data_model.h"`, `<stdlib.h>`, `<string.h>`.
  </action>
  <verify>
  Build compiles: `cd /home/cachy/workspaces/libs/cels/tools/cels-debug && cmake --build build 2>&1 | tail -10`
  </verify>
  <done>tab_components.h/c implement the Components tab with split panel, scrollable component type list (left) sorted alphabetically, and filtered entity list (right) showing entities with the selected component.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Components tab into tab system and build</name>
  <files>
    tools/cels-debug/src/tab_system.c
    tools/cels-debug/CMakeLists.txt
  </files>
  <action>
  **tab_system.c changes:**
  1. Add include: `#include "tabs/tab_components.h"`
  2. In the tab_defs array, replace the "Components" entry (index 2) from placeholder to real implementation:
     ```c
     { "Components",   ENDPOINT_COMPONENTS | ENDPOINT_QUERY,
       tab_components_init, tab_components_fini,
       tab_components_draw, tab_components_input },
     ```
     The bitmask includes ENDPOINT_QUERY because the Components tab right panel filters from the entity list (which is fetched via /query). Also includes ENDPOINT_COMPONENTS for the component registry.

  **CMakeLists.txt changes:**
  Add `src/tabs/tab_components.c` to the add_executable source list, after tab_entities.c.

  **Update footer help text in tui.c:**
  The footer currently shows "1-6:tabs  TAB:next  q:quit". This is still correct as a base, but consider adding context-sensitive hints. For Phase 03 scope, the base footer is sufficient. The Entities and Components tabs can optionally render additional help text in their own draw functions at the bottom of their panels (inside the border). Example: in the left panel bottom border area of Entities tab, render "j/k:nav Enter:expand f:anon" in A_DIM. This is optional -- only add if it doesn't complicate the border rendering.

  Actually, a simpler approach: add a line in the footer area that's context-sensitive. But the footer is a single-line window. So leave the footer as-is for now and optionally show key hints in the panel title area or as a bottom line inside the panel content area.

  SKIP the context-sensitive footer for this plan. Keep it simple.
  </action>
  <verify>
  Build compiles: `cd /home/cachy/workspaces/libs/cels/tools/cels-debug && cmake -B build -DCMAKE_BUILD_TYPE=Debug && cmake --build build 2>&1 | tail -10`
  Verify tab_components is wired: `grep 'tab_components' src/tab_system.c` shows the vtable entry.
  Verify CMake includes the file: `grep 'tab_components' CMakeLists.txt` shows the source file.
  Verify all 6 tabs have their correct vtable: `grep -A1 'tab_defs\[' src/tab_system.c` or just review the full tab_defs array.
  </verify>
  <done>Components tab replaces placeholder in tab_defs. Binary compiles and links. Switching to tab 3 (Components) shows the split panel with component type list and entity drill-down instead of "Not implemented yet". All Phase 03 success criteria are met: entity list, component inspection, component registry, virtual scrolling.</done>
</task>

</tasks>

<verification>
1. `cmake --build build` succeeds
2. Tab 3 shows split panel with "Components" and "Entities" titled borders
3. When connected, component types list populates in left panel with entity counts
4. Selecting a component shows matching entities in right panel
5. j/k scrolls both panels, left/right switches focus
6. All Phase 03 roadmap success criteria met:
   - Entities tab shows scrollable entity list from /query (criterion 1)
   - j/k and arrow keys navigate, Enter selects (criterion 2)
   - Selected entity shows component key-value pairs (criterion 3)
   - Nested objects and arrays render correctly (criterion 4)
   - Components tab lists registered types (criterion 5)
   - Entity list handles large counts with virtual scrolling (criterion 6)
</verification>

<success_criteria>
The Components tab is fully interactive: users browse all component types sorted alphabetically, see entity counts, and drill down to see which entities have a specific component. Phase 03 is complete with both the Entities and Components tabs working.
</success_criteria>

<output>
After completion, create `.planning/phases/03-entities-and-components/03-04-SUMMARY.md`
</output>
