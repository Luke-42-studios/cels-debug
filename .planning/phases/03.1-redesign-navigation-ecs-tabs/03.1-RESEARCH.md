# Phase 03.1: Redesign Navigation -- ECS Tabs - Research

**Researched:** 2026-02-06
**Domain:** ncurses TUI tab restructuring, tree view navigation with section headers, component browser integration
**Confidence:** HIGH

## Summary

Phase 03.1 is a structural refactoring of the cels-debug tab and navigation system. The current 5-tab layout (Overview, Entities, Systems, Performance, State) must be consolidated into a 4-tab layout (Overview, ECS, Performance, State), with the ECS tab becoming a unified CELS-C browser containing collapsible section headers (Compositions, Entities, Lifecycles, Systems, Components) and a split-panel inspector.

The critical finding from code analysis is that **most of the required functionality already exists** in the current codebase. The tree_view module already renders CELS-C section headers with bold first letters, collapse/expand behavior, and cursor navigation through headers. The tab_entities module already has entity classification, split panel layout, and the component inspector. The tab_components module has the component registry browsing. The work is primarily reorganization and wiring, not new feature development.

**Primary recommendation:** Rename/restructure tab_entities into tab_ecs, absorb the Components section browsing from tab_components, reduce TAB_COUNT from 5 to 4, and update all touch points (tab_system.c definitions, main.c key range, tui.c footer text, CMakeLists.txt). The tree_view and split_panel modules need zero changes -- they already implement the required behavior.

## Standard Stack

This phase uses no new libraries or dependencies. All required functionality is built from existing modules.

### Core (Existing, No Changes Needed)
| Module | File | Purpose | Why No Change |
|--------|------|---------|---------------|
| tree_view | tree_view.h/c | Section headers, collapse, cursor, DFS | Already implements CELS-C sections with bold first letter |
| split_panel | split_panel.h/c | Left/right panel layout with focus | Already used by tab_entities |
| scroll | scroll.h/c | Virtual scrolling with cursor tracking | Already used by tree and inspector |
| json_render | json_render.h/c | Component value rendering | Already used by inspector |
| data_model | data_model.h/c | Entity/component data structures | Already has entity_class_t, component_registry_t |

### Core (Existing, Modifications Needed)
| Module | File | Change Required | Reason |
|--------|------|-----------------|--------|
| tab_system | tab_system.h/c | TAB_COUNT 5->4, redefine tab_defs array | Fewer tabs, different names and endpoints |
| tui | tui.c | Footer help text update | "1-4:tabs" instead of "1-5:tabs" |
| main | main.c | Key range '1'-'4' instead of '1'-'5' | 4 tabs not 5 |
| CMakeLists.txt | CMakeLists.txt | Replace source file entries | tab_entities.c -> tab_ecs.c, remove tab_components.c |

### New Files
| Module | File | Purpose |
|--------|------|---------|
| tab_ecs | tabs/tab_ecs.h | ECS tab header (vtable functions) |
| tab_ecs | tabs/tab_ecs.c | ECS tab implementation (merged entities + components) |

### Files to Remove
| File | Reason |
|------|--------|
| tabs/tab_entities.h | Replaced by tab_ecs.h |
| tabs/tab_entities.c | Replaced by tab_ecs.c (logic absorbed) |
| tabs/tab_components.h | Component browsing moved into ECS tab's Components section |
| tabs/tab_components.c | Component browsing moved into ECS tab's Components section |

## Architecture Patterns

### Current Architecture (5 tabs)
```
tab_system.c tab_defs[5]:
  [0] "Overview"     -> tab_overview     (ENDPOINT_STATS_WORLD | ENDPOINT_QUERY)
  [1] "Entities"     -> tab_entities     (ENDPOINT_QUERY | ENDPOINT_ENTITY | ENDPOINT_COMPONENTS)
  [2] "Systems"      -> tab_placeholder  (ENDPOINT_STATS_PIPELINE)
  [3] "Performance"  -> tab_placeholder  (ENDPOINT_STATS_WORLD | ENDPOINT_STATS_PIPELINE)
  [4] "State"        -> tab_placeholder  (ENDPOINT_NONE)
```

### Target Architecture (4 tabs)
```
tab_system.c tab_defs[4]:
  [0] "Overview"     -> tab_overview     (ENDPOINT_STATS_WORLD | ENDPOINT_QUERY)
  [1] "ECS"          -> tab_ecs          (ENDPOINT_QUERY | ENDPOINT_ENTITY | ENDPOINT_COMPONENTS)
  [2] "Performance"  -> tab_placeholder  (ENDPOINT_STATS_WORLD | ENDPOINT_STATS_PIPELINE)
  [3] "State"        -> tab_placeholder  (ENDPOINT_NONE)
```

### Key Change: Tab Definition Array

The tab_defs array in tab_system.c changes from 5 entries to 4. The "Entities" slot becomes "ECS" with the same endpoints (QUERY | ENTITY | COMPONENTS). The "Systems" placeholder is removed -- system entities already appear under the "Systems" section header in the CELS-C tree, and the dedicated Systems tab from Phase 04 will be built separately if still needed.

### ECS Tab Internal Structure

The ECS tab reuses the existing split panel + tree view architecture from tab_entities:

```
+-- ECS Tab (split_panel_t) ----------------------------------------+
|                                |                                   |
|  Left: CELS-C Tree View       |  Right: Inspector                 |
|  (40% width)                  |  (60% width)                      |
|                                |                                   |
|  > Compositions (3)            |  Position                         |
|  > Entities (12)               |    x: 10.0                        |
|  > Lifecycles (2)              |    y: 20.5                        |
|  > Systems (8)                 |  Velocity                         |
|  v Components (15)             |    x: 1.0                         |
|    Text           [3 entities] |    y: 2.0                         |
|    ClickArea      [5 entities] |                                   |
|    Position       [12 entities]|                                   |
|                                |                                   |
+--------------------------------+-----------------------------------+
```

### Pattern: Components Section in Tree View

The Components section requires special treatment compared to other CELS-C sections. When expanded, it should show component TYPE names (from component_registry) rather than entity nodes from the entity tree. This is the key architectural decision for this phase.

**Two approaches:**

**Approach A: Unified display_row_t with component_info rows**
Extend display_row_t to handle a third row type (component info row) in addition to section headers and entity nodes. The Components section populates from component_registry instead of entity_list.

```c
typedef struct display_row {
    entity_node_t *node;        /* Non-NULL = entity row */
    component_info_t *comp;     /* Non-NULL = component type row */
    int section_idx;            /* Which CELS-C section */
} display_row_t;
```

**Approach B: Keep Components as entity nodes (current behavior)**
Component entities already appear in the entity tree under ENTITY_CLASS_COMPONENT (classified by `has_component_component()`). The tree view already groups them under the "Components" section header. This means Components section items are already entity nodes with names like "Text", "Position", etc.

**Recommendation: Approach B** -- The current classification in tab_entities.c already correctly classifies component type entities into ENTITY_CLASS_COMPONENT, and tree_view.c already groups them under the "Components" section header. The component_registry data (entity counts, sizes) can be shown as right-aligned annotations on these entity rows in the tree, similar to how component names are shown on entity rows. No structural changes to display_row_t are needed.

The inspector panel (right side) already shows component details when an entity node is selected. For a component TYPE entity selected from the Components section, the inspector shows:
- Component name and metadata (entity count, size from registry)
- List of entities that have this component (filtered from entity_list, same logic as tab_components right panel)

**This means the inspector behavior must be context-sensitive:**
- Entity selected from Compositions/Entities/Lifecycles/Systems section -> show entity's component values (current behavior)
- Component type selected from Components section -> show entities that have this component (from tab_components logic)

### Pattern: Context-Sensitive Inspector

The inspector panel behavior depends on which section the selected item belongs to:

```c
/* In draw function, after rendering left panel tree */
display_row_t *cur = &tree->rows[tree->scroll.cursor];

if (cur->node && cur->node->entity_class == ENTITY_CLASS_COMPONENT) {
    /* Components section: show entities with this component type */
    render_component_entities(rwin, cur->node, state);
} else if (cur->node) {
    /* Other sections: show entity's component values */
    render_entity_detail(rwin, cur->node, state);
} else {
    /* Section header selected: show section summary or "expand to browse" */
    render_section_info(rwin, cur->section_idx);
}
```

### Anti-Patterns to Avoid

- **Duplicating tree_view logic:** The tree_view module already handles section headers, collapse, cursor navigation, and bold first letters. Do NOT reimplement any of this in tab_ecs.
- **Breaking the vtable pattern:** The new tab_ecs must follow the exact same init/fini/draw/handle_input signature as existing tabs. Do NOT add special cases in tab_system.c.
- **Leaving dead code:** When tab_entities.c and tab_components.c are removed, ensure all their unique logic is migrated to tab_ecs.c, not lost.
- **Hardcoding TAB_COUNT in multiple places:** TAB_COUNT is defined once in tab_system.h. The main.c key range check (`ch >= '1' && ch <= '5'`) is the only other hardcoded reference -- update it to use TAB_COUNT or update the literal.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Section headers with collapse | Custom section rendering | tree_view.c (already has it) | draw_section_header() with bold first letter already implemented |
| Virtual scrolling through sections | Custom scroll logic | scroll.h + tree_view rebuild_visible | Already handles mixed header + entity rows |
| Split panel with focus | Custom window management | split_panel.h (already has it) | Focus switching, border rendering, resize all work |
| Entity classification | New classifier | tab_entities.c classify_node() | Move this function to tab_ecs.c verbatim |
| Component value rendering | Custom JSON printer | json_render.h (already has it) | Recursive renderer with color pairs |

**Key insight:** This phase is 90% reorganization of existing code, not new development. The tree_view, split_panel, scroll, and json_render modules are reusable infrastructure that needs zero changes.

## Common Pitfalls

### Pitfall 1: Forgetting to Update TAB_COUNT References
**What goes wrong:** TAB_COUNT changes from 5 to 4, but main.c still checks `ch >= '1' && ch <= '5'`, causing an out-of-bounds tab activation attempt.
**Why it happens:** TAB_COUNT is a #define in tab_system.h, but main.c has a hardcoded '5' character literal.
**How to avoid:** Search all files for the literal '5' related to tab count. Update to '4' or derive from TAB_COUNT: `ch <= '0' + TAB_COUNT`.
**Warning signs:** Pressing '5' in the TUI causes undefined behavior or activates a non-existent tab slot.

### Pitfall 2: Components Section Inspector Mode
**What goes wrong:** Selecting a component type entity from the Components section shows a generic entity detail (component values of the component TYPE entity itself) instead of a list of entities that HAVE that component.
**Why it happens:** The inspector in tab_entities.c always shows entity_detail from `/entity/<path>`. For component type entities, the useful view is "which entities have this component" (from tab_components.c logic).
**How to avoid:** Check `entity_class` of the selected node. If `ENTITY_CLASS_COMPONENT`, use the component-entities-list rendering logic from tab_components.c instead of the standard entity detail inspector.
**Warning signs:** Selecting "Position" in Components section shows "Position" entity's own components rather than all entities with Position.

### Pitfall 3: Required Endpoints Bitmask
**What goes wrong:** The ECS tab needs ENDPOINT_COMPONENTS for the Components section, but the current tab_entities only uses ENDPOINT_QUERY | ENDPOINT_ENTITY. Missing ENDPOINT_COMPONENTS means component registry data is never fetched.
**Why it happens:** The original Entities tab did not use the component registry. The original Components tab declared ENDPOINT_COMPONENTS separately.
**How to avoid:** The ECS tab definition must include all three: `ENDPOINT_QUERY | ENDPOINT_ENTITY | ENDPOINT_COMPONENTS`.
**Warning signs:** Components section shows component entities from the tree (with names but no entity_count or size metadata), but not the rich registry data.

### Pitfall 4: Component Entity Annotation Data
**What goes wrong:** Component type entities in the tree show no useful metadata (no entity count, no size). The tree currently shows `class_detail` or component names for right-aligned annotations, but component type entities may not have useful data there.
**Why it happens:** Component type entities are classified with class_detail set to NULL (unlike systems which get "OnLoad", "Observer" etc.). Their component_names list might contain "Component" and other internal flecs components.
**How to avoid:** When building the tree, cross-reference component type entities with component_registry to annotate them with entity_count and size. Set class_detail to something like "15 entities, 8B" for rich display.
**Warning signs:** Component rows in the tree have no right-aligned annotation text.

### Pitfall 5: Split Panel Window Lifecycle on Tab Switch
**What goes wrong:** Switching away from ECS tab and back causes panel windows to be stale or not exist. The panels are created lazily on first draw, but if dimensions changed while another tab was active, they may be wrong.
**Why it happens:** Tab draw is only called for the active tab. Split panel dimensions are checked each draw call.
**How to avoid:** The existing tab_entities.c pattern already handles this correctly: check `panel_created` flag, and compare current dimensions on each draw. Copy this pattern to tab_ecs.c.
**Warning signs:** Panels appear at wrong position or size after switching tabs and resizing.

### Pitfall 6: Footer Help Text Out of Sync
**What goes wrong:** Footer says "1-5:tabs" but there are only 4 tabs. User presses '5' and nothing happens.
**Why it happens:** Footer text in tui.c is a hardcoded string.
**How to avoid:** Update the footer text to "1-4:tabs" when TAB_COUNT changes to 4.
**Warning signs:** Visual inconsistency in the footer bar.

### Pitfall 7: Entity Classification Function Ownership
**What goes wrong:** The `classify_node()` and related helper functions (`has_tag()`, `has_component_component()`, `extract_pipeline_phase()`, `name_is_lifecycle()`, `classify_all_entities()`, `propagate_class()`) are defined as static functions in tab_entities.c. When tab_entities.c is removed, these functions are lost.
**Why it happens:** They were written as tab-private helpers.
**How to avoid:** Move all classification functions to tab_ecs.c (same file, just renamed). They can remain static since only the ECS tab needs them. Alternatively, move to a shared classifier module if future phases need them.
**Warning signs:** Compilation errors when tab_entities.c is removed.

## Code Examples

### Example 1: Updated tab_defs Array
```c
/* Source: current tab_system.c, modified for 4 tabs */
#include "tabs/tab_overview.h"
#include "tabs/tab_ecs.h"
#include "tabs/tab_placeholder.h"

static const tab_def_t tab_defs[TAB_COUNT] = {
    { "Overview",     ENDPOINT_STATS_WORLD | ENDPOINT_QUERY,
      tab_overview_init, tab_overview_fini,
      tab_overview_draw, tab_overview_input },
    { "ECS",          ENDPOINT_QUERY | ENDPOINT_ENTITY | ENDPOINT_COMPONENTS,
      tab_ecs_init, tab_ecs_fini,
      tab_ecs_draw, tab_ecs_input },
    { "Performance",  ENDPOINT_STATS_WORLD | ENDPOINT_STATS_PIPELINE,
      tab_placeholder_init, tab_placeholder_fini,
      tab_placeholder_draw, tab_placeholder_input },
    { "State",        ENDPOINT_NONE,
      tab_placeholder_init, tab_placeholder_fini,
      tab_placeholder_draw, tab_placeholder_input },
};
```

### Example 2: Context-Sensitive Inspector in tab_ecs Draw
```c
/* Inside tab_ecs_draw(), after rendering the left panel tree: */
entity_node_t *sel = tree_view_selected(&es->tree);

if (sel && sel->entity_class == ENTITY_CLASS_COMPONENT) {
    /* Components section: show entities that have this component */
    const char *comp_name = sel->name;
    if (comp_name && state->entity_list) {
        /* Filter entities with matching component (same as tab_components) */
        for (int i = 0; i < state->entity_list->count; i++) {
            entity_node_t *node = state->entity_list->nodes[i];
            for (int c = 0; c < node->component_count; c++) {
                if (strcmp(node->component_names[c], comp_name) == 0) {
                    /* Add to matches list, render in right panel */
                    break;
                }
            }
        }
    }
} else if (sel && state->entity_detail) {
    /* Standard entity inspection (same as current tab_entities) */
    if (strcmp(state->entity_detail->path, sel->full_path) == 0) {
        /* Render component values... */
    }
}
```

### Example 3: Component Entity Annotation from Registry
```c
/* During classify_all_entities(), enrich component entities with registry data */
static void annotate_component_entities(entity_list_t *list,
                                         component_registry_t *reg) {
    if (!list || !reg) return;
    for (int i = 0; i < list->root_count; i++) {
        entity_node_t *node = list->roots[i];
        if (node->entity_class != ENTITY_CLASS_COMPONENT) continue;
        if (!node->name) continue;

        /* Find matching registry entry */
        for (int r = 0; r < reg->count; r++) {
            if (reg->components[r].name &&
                strcmp(reg->components[r].name, node->name) == 0) {
                free(node->class_detail);
                char buf[64];
                if (reg->components[r].has_type_info && reg->components[r].size > 0) {
                    snprintf(buf, sizeof(buf), "%d entities, %dB",
                             reg->components[r].entity_count,
                             reg->components[r].size);
                } else {
                    snprintf(buf, sizeof(buf), "%d entities",
                             reg->components[r].entity_count);
                }
                node->class_detail = strdup(buf);
                break;
            }
        }
    }
}
```

### Example 4: Main Loop Key Range Update
```c
/* In main.c, update tab switching key range: */
if (ch >= '1' && ch <= '0' + TAB_COUNT) {   /* Was: ch <= '5' */
    tab_system_activate(&tabs, ch - '1');
}
```

### Example 5: Updated Footer Text
```c
/* In tui.c tui_render(), update footer: */
mvwprintw(win_footer, 0, 1,
    "1-4:tabs  jk:nav  Enter:expand  f:anon  q:quit");
/* Was: "1-5:tabs  jk:nav  Enter:expand  f:anon  q:quit" */
```

## Change Impact Analysis

### Files Modified (5 files)
| File | Change | Size | Risk |
|------|--------|------|------|
| tab_system.h | TAB_COUNT 5->4 | 1 line | LOW |
| tab_system.c | New tab_defs[4], include tab_ecs.h instead of tab_entities.h | ~10 lines | LOW |
| main.c | Key range '5' -> '0'+TAB_COUNT | 1 line | LOW |
| tui.c | Footer "1-5" -> "1-4" | 1 line | LOW |
| CMakeLists.txt | Replace tab_entities.c with tab_ecs.c, remove tab_components.c | 2 lines | LOW |

### Files Created (2 files)
| File | Content Source | Size Estimate |
|------|---------------|---------------|
| tabs/tab_ecs.h | Based on tab_entities.h | ~12 lines |
| tabs/tab_ecs.c | Merge tab_entities.c + tab_components.c | ~450 lines |

### Files Removed (4 files)
| File | Reason |
|------|--------|
| tabs/tab_entities.h | Replaced by tab_ecs.h |
| tabs/tab_entities.c | Logic migrated to tab_ecs.c |
| tabs/tab_components.h | Component browsing moved into ECS tab |
| tabs/tab_components.c | Component browsing moved into ECS tab |

### Files Unchanged (10 files)
| File | Why No Change |
|------|---------------|
| tree_view.h/c | Already implements CELS-C sections, bold first letter, collapse |
| split_panel.h/c | Already implements focus switching, border styles |
| scroll.h/c | Already implements virtual scrolling |
| json_render.h/c | Already implements component value rendering |
| data_model.h/c | Already has entity_class_t and component_registry_t |
| http_client.h/c | No changes needed |
| json_parser.h/c | No changes needed |
| tabs/tab_overview.h/c | No changes needed |
| tabs/tab_placeholder.h/c | No changes needed |
| tui.h | No changes needed (color pairs already defined) |

## Verification Checklist (from Success Criteria)

1. **Top-level tabs are: Overview, ECS, Performance, State (4 tabs, not 5+)**
   - Verify: TAB_COUNT == 4 in tab_system.h
   - Verify: tab_defs array has exactly 4 entries with correct names
   - Verify: Tab bar renders 4 labels

2. **ECS tab contains the CELS-C tree view with collapsible section headers**
   - Verify: tree_view_render() called in tab_ecs_draw()
   - Verify: All 5 CELS-C sections appear when entities exist

3. **Components section within CELS-C is fully functional**
   - Verify: Component type entities classified under ENTITY_CLASS_COMPONENT
   - Verify: Selecting a component shows entities-with-component list in inspector
   - Verify: Component entity_count annotation visible in tree

4. **Section headers are navigable, Enter toggles collapse, all start collapsed**
   - Verify: tree_view_init() sets section_collapsed[i] = true (already does)
   - Verify: tree_view_toggle_expand() handles section header toggle (already does)

5. **First letter of each section name is bold**
   - Verify: draw_section_header() in tree_view.c uses A_BOLD on name[0] (already does)

6. **Arrow keys / j/k navigation works correctly**
   - Verify: tab_ecs_input() handles j/k/UP/DOWN via scroll_move (same as tab_entities)

7. **Inspector panel shows entity detail when entity selected from any section**
   - Verify: sync_selected_path() called on cursor movement
   - Verify: Entity detail rendered in right panel for non-Component entities
   - Verify: Component entity list rendered for Component section items

## Open Questions

1. **Inspector behavior for section headers**
   - What we know: When cursor is on a section header (node == NULL), tree_view_selected() returns NULL. The current tab_entities shows "Select an entity" message.
   - What's unclear: Should the inspector show section-level info (e.g., "12 entities" for the Entities section)?
   - Recommendation: Keep the simple "Select an entity" message. Users will quickly learn to expand and select. Enhancement can come later.

2. **Component entity detail vs. entities-with-component**
   - What we know: Component type entities (like "Position") exist in the flecs world as real entities. Selecting one could show either: (a) the component entity's own components/tags, or (b) a list of entities that have this component type.
   - What's unclear: Which view is more useful to the developer?
   - Recommendation: Show entities-with-component (option b), matching the current tab_components behavior. The component entity's own metadata is less useful for debugging. If needed, the raw entity detail could be a secondary mode toggled with a key.

3. **Systems tab removal**
   - What we know: The current "Systems" tab (index 2) is a placeholder. Phase 04 plans to build a Systems and Pipeline tab. Removing it from the top level means Phase 04 must either add it back or integrate it differently.
   - What's unclear: Whether Phase 04 should add a 5th tab or extend the ECS tab further.
   - Recommendation: Leave Phase 04 scope unchanged. It can add "Systems" back as a 5th tab if pipeline visualization needs its own space, or it can enhance the Systems section within ECS. That decision is deferred.

## Sources

### Primary (HIGH confidence)
- All cels-debug source files read directly from `/home/cachy/workspaces/libs/cels/tools/cels-debug/src/`
- tree_view.c lines 13-20 (section_names), 62-74 (init with collapsed sections), 192-222 (draw_section_header with bold first letter)
- tab_entities.c lines 24-109 (classification logic), 224-234 (sync_selected_path), 266-471 (draw with split panel)
- tab_components.c lines 54-255 (draw with component registry and entity filtering)
- tab_system.c lines 7-23 (tab_defs array)
- main.c lines 67-73 (tab switching key handling)
- tui.c line 172 (footer help text)

### Secondary (MEDIUM confidence)
- Phase 03 RESEARCH.md -- flecs REST API endpoints and data formats
- Phase 03 plans 01-04 -- architectural decisions carried forward

## Metadata

**Confidence breakdown:**
- Tab restructuring: HIGH -- direct code analysis, straightforward refactoring
- Tree view reuse: HIGH -- verified all required features already implemented
- Component section inspector: HIGH -- tab_components.c logic can be directly migrated
- Integration points: HIGH -- all touch points identified from source

**Research date:** 2026-02-06
**Valid until:** 2026-03-06 (internal refactoring, no external dependency changes)
