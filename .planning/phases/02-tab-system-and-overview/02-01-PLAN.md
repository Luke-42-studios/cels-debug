---
phase: 02-tab-system-and-overview
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tools/cels-debug/src/tab_system.h
  - tools/cels-debug/src/tab_system.c
  - tools/cels-debug/src/tabs/tab_placeholder.h
  - tools/cels-debug/src/tabs/tab_placeholder.c
  - tools/cels-debug/src/tui.h
  - tools/cels-debug/src/tui.c
  - tools/cels-debug/src/main.c
  - tools/cels-debug/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Tab bar renders 6 tab labels (Overview, Entities, Components, Systems, State, Performance) horizontally with active tab highlighted using A_REVERSE"
    - "User presses 1-6 to jump directly to a tab; active highlight moves to the selected tab"
    - "User presses TAB to cycle forward through tabs (wraps from 6 back to 1)"
    - "Switching to a placeholder tab shows centered 'Not implemented yet' text in the content area"
    - "Polling only occurs for endpoints declared by the active tab's required_endpoints bitmask"
    - "Connection health is maintained: header still shows Connected/Disconnected/Reconnecting correctly"
  artifacts:
    - path: "tools/cels-debug/src/tab_system.h"
      provides: "Tab vtable types (tab_def_t, tab_t, tab_system_t), endpoint_t enum, public API"
      contains: "tab_def_t"
    - path: "tools/cels-debug/src/tab_system.c"
      provides: "Tab system implementation with tab_defs array, init/fini/activate/next/draw/handle_input/required_endpoints"
      contains: "tab_system_init"
    - path: "tools/cels-debug/src/tabs/tab_placeholder.h"
      provides: "Placeholder tab function declarations"
      contains: "tab_placeholder_draw"
    - path: "tools/cels-debug/src/tabs/tab_placeholder.c"
      provides: "Placeholder tab rendering centered 'Not implemented yet' text"
      contains: "Not implemented yet"
    - path: "tools/cels-debug/src/tui.c"
      provides: "4-window layout (header, tabbar, content, footer) with tab bar rendering"
      contains: "win_tabbar"
    - path: "tools/cels-debug/src/main.c"
      provides: "Input routing (global -> tab switch -> per-tab), smart polling with endpoint bitmask, app_state_t"
      contains: "tab_system_required_endpoints"
  key_links:
    - from: "tools/cels-debug/src/main.c"
      to: "tools/cels-debug/src/tab_system.h"
      via: "tab_system_activate(), tab_system_next(), tab_system_handle_input()"
      pattern: "tab_system_(activate|next|handle_input)"
    - from: "tools/cels-debug/src/tui.c"
      to: "tools/cels-debug/src/tab_system.h"
      via: "tab_system_draw() dispatches active tab's draw function with win_content"
      pattern: "tab_system_draw"
    - from: "tools/cels-debug/src/main.c"
      to: "tools/cels-debug/src/tab_system.h"
      via: "tab_system_required_endpoints() gates HTTP polling"
      pattern: "tab_system_required_endpoints.*ENDPOINT_STATS_WORLD"
---

<objective>
Create the tab vtable framework, tab bar UI, and keyboard navigation with 6 tabs (Overview as placeholder initially, plus 5 other placeholder tabs). Refactor main.c for input routing and smart polling, and refactor tui.c for the 4-window layout with tab bar rendering.

Purpose: This is the core framework that all future phases build on. The tab vtable (T9) enables per-tab behavior dispatch, the endpoint bitmask enables smart polling (only fetching what the active tab needs), and the tab bar gives users visible navigation.

Output: A working TUI with a visible tab bar, keyboard-driven tab switching (1-6 and TAB), placeholder content for all 6 tabs, and smart polling that only fetches endpoints the active tab declares.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/STATE.md
@tools/cels-debug/.planning/phases/02-tab-system-and-overview/02-RESEARCH.md

Phase 01 source files (the code being modified):
@tools/cels-debug/src/main.c
@tools/cels-debug/src/tui.c
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/http_client.h
@tools/cels-debug/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tab_system module and placeholder tab</name>
  <files>
    tools/cels-debug/src/tab_system.h
    tools/cels-debug/src/tab_system.c
    tools/cels-debug/src/tabs/tab_placeholder.h
    tools/cels-debug/src/tabs/tab_placeholder.c
  </files>
  <action>
Create `src/tabs/` directory. Then create 4 new files:

**tab_system.h** -- Public API for the tab system. Follow the exact design from the research (Pattern 1 + Pattern 2):
- `endpoint_t` enum with bitmask values: `ENDPOINT_NONE=0`, `ENDPOINT_STATS_WORLD=(1u<<0)`, `ENDPOINT_STATS_PIPELINE=(1u<<1)`, `ENDPOINT_QUERY=(1u<<2)`, `ENDPOINT_ENTITY=(1u<<3)`, `ENDPOINT_COMPONENTS=(1u<<4)`, `ENDPOINT_WORLD=(1u<<5)`.
- `tab_def_t` struct: `name` (const char*), `required_endpoints` (uint32_t), plus 4 function pointers: `init(tab_t*)`, `fini(tab_t*)`, `draw(const tab_t*, WINDOW*, const void* app_state)`, `handle_input(tab_t*, int ch, void* app_state)`.
- `tab_t` struct: `def` (const tab_def_t*), `state` (void*).
- `tab_system_t` struct: `tabs[TAB_COUNT]` array, `active` int index. `#define TAB_COUNT 6`.
- Public functions: `tab_system_init`, `tab_system_fini`, `tab_system_activate`, `tab_system_next`, `tab_system_handle_input`, `tab_system_draw`, `tab_system_required_endpoints`.
- Use `void*` for app_state in function signatures (avoids circular includes). Tab .c files cast internally.
- Include `<ncurses.h>`, `<stdbool.h>`, `<stdint.h>`.

**tab_system.c** -- Implementation:
- Static const `tab_defs[TAB_COUNT]` array. For this task, ALL 6 slots use placeholder functions. Tab names: "Overview", "Entities", "Components", "Systems", "State", "Performance". Required endpoints per research: Overview=ENDPOINT_STATS_WORLD, Entities=ENDPOINT_QUERY, Components=ENDPOINT_COMPONENTS, Systems=ENDPOINT_STATS_PIPELINE, State=ENDPOINT_NONE, Performance=ENDPOINT_STATS_WORLD|ENDPOINT_STATS_PIPELINE.
- `tab_system_init`: sets active=0, loops through tabs assigning def pointers and calling init.
- `tab_system_fini`: loops through tabs calling fini.
- `tab_system_activate`: bounds-checks index [0, TAB_COUNT), sets active.
- `tab_system_next`: `active = (active + 1) % TAB_COUNT`.
- `tab_system_handle_input`: delegates to active tab's handle_input; returns its bool result. If handle_input is NULL, return false.
- `tab_system_draw`: delegates to active tab's draw with win and app_state. If draw is NULL, do nothing.
- `tab_system_required_endpoints`: returns active tab's `def->required_endpoints`.

**tabs/tab_placeholder.h** -- Function declarations for the shared placeholder tab:
- `tab_placeholder_init`, `tab_placeholder_fini`, `tab_placeholder_draw`, `tab_placeholder_input`.
- Include guard: `CELS_DEBUG_TAB_PLACEHOLDER_H`.

**tabs/tab_placeholder.c** -- Implementation:
- `init`: sets `self->state = NULL`.
- `fini`: no-op (void cast self).
- `draw`: Centers "Not implemented yet" horizontally and vertically in the content window using `getmaxy(win)/2` and `(getmaxx(win) - strlen(msg))/2`. Below that, render the tab name from `self->def->name` in A_DIM.
- `input`: returns false (no interactive elements). Void cast all params.
- Include `<string.h>` for `strlen`.
  </action>
  <verify>
All 4 files compile without errors when added to CMakeLists.txt (verified in Task 2). For now, verify the files exist and have correct include guards:
- `grep -c "tab_system_init" tools/cels-debug/src/tab_system.c` returns >= 1
- `grep -c "tab_placeholder_draw" tools/cels-debug/src/tabs/tab_placeholder.c` returns >= 1
  </verify>
  <done>
tab_system.h declares the complete vtable API (tab_def_t, tab_t, tab_system_t, endpoint_t, 7 public functions). tab_system.c implements all functions with 6 placeholder tabs. tab_placeholder.c renders centered "Not implemented yet" text. No compilation tested yet (that happens when integrated in Task 2).
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor tui.c, main.c, and CMakeLists.txt for tab integration</name>
  <files>
    tools/cels-debug/src/tui.h
    tools/cels-debug/src/tui.c
    tools/cels-debug/src/main.c
    tools/cels-debug/CMakeLists.txt
  </files>
  <action>
**CMakeLists.txt** -- Add new source files to the `add_executable` list:
- `src/tab_system.c`
- `src/tabs/tab_placeholder.c`

(tab_overview.c is added in Plan 02, not here.)

**tui.h** -- Change the render signature and add forward declarations:
- Forward-declare `tab_system_t` (do NOT include tab_system.h to avoid pulling ncurses into the header chain unnecessarily -- tui.h already includes data_model.h and http_client.h). Actually, since tui.h needs `tab_system_t` and `tab_system_t` is defined in tab_system.h which already includes ncurses.h, it is cleaner to just `#include "tab_system.h"` in tui.h.
- Define `app_state_t` struct in tui.h (or a new app_state.h -- but to keep it simple, define it in tui.h since tui.h already includes data_model.h and http_client.h which provide the types it needs): `typedef struct app_state { world_snapshot_t *snapshot; connection_state_t conn_state; } app_state_t;`
- Change `tui_render` signature from `tui_render(const world_snapshot_t *snapshot, connection_state_t conn_state)` to `tui_render(const tab_system_t *tabs, const app_state_t *state)`.
- Keep `tui_init`, `tui_fini`, `tui_resize` unchanged.
- Add `WINDOW *tui_get_content_win(void);` so tui_render can pass win_content to tab_system_draw.

Actually, tui_render itself calls tab_system_draw internally -- so it doesn't need to expose win_content publicly. tui.c includes tab_system.h and calls tab_system_draw(tabs, win_content, state) inside tui_render. So tui_get_content_win is NOT needed. Keep the API clean.

**tui.c** -- Major modifications:
1. Add `#include "tab_system.h"` at the top.
2. Add color pairs for tab bar: `#define CP_TAB_ACTIVE 5` and `#define CP_TAB_INACTIVE 6`. Initialize them in `tui_init`: `init_pair(CP_TAB_ACTIVE, COLOR_WHITE, -1)` and `init_pair(CP_TAB_INACTIVE, COLOR_WHITE, -1)`. (Active uses A_REVERSE|A_BOLD so the color pair itself can be simple.)
3. Add `static WINDOW *win_tabbar = NULL;` alongside existing windows.
4. Modify `create_windows`: insert tab bar at row 1 height 1, shift content to row 2 height LINES-3. Layout:
   - `win_header  = newwin(1, COLS, 0, 0);`
   - `win_tabbar  = newwin(1, COLS, 1, 0);`
   - `win_content = newwin(LINES - 3, COLS, 2, 0);`
   - `win_footer  = newwin(1, COLS, LINES - 1, 0);`
5. Modify `destroy_windows`: add `delwin(win_tabbar)` with NULL check/reset.
6. Modify `tui_render(const tab_system_t *tabs, const app_state_t *state)`:
   - Header: use `state->conn_state` instead of the old `conn_state` param. Same rendering logic (Connected/Disconnected/Reconnecting with color pairs).
   - Tab bar: werase win_tabbar, then loop through `tabs->tabs[i]`, printing " N:Name " for each tab (N=i+1). Active tab (i == tabs->active) uses `A_REVERSE | A_BOLD | COLOR_PAIR(CP_TAB_ACTIVE)`. Inactive tabs use `COLOR_PAIR(CP_TAB_INACTIVE)`. Track column position manually. Use `snprintf(NULL, 0, " %d:%s ", i+1, name)` to compute label width for advancing the column.
   - Content: werase win_content, then call `tab_system_draw(tabs, win_content, state)` to delegate to the active tab's draw function. REMOVE the old inline entity/FPS/frame_time rendering -- that moves to tab_overview in Plan 02.
   - Footer: change help text from "q: quit" to "1-6:tabs  TAB:next  q:quit".
   - Batch refresh: add `wnoutrefresh(win_tabbar)` between header and content refreshes, then `doupdate()`.

**main.c** -- Major modifications:
1. Add `#include "tab_system.h"` and the header that defines `app_state_t` (which is now in tui.h, already included).
2. Replace the separate `world_snapshot_t *snapshot` and `connection_state_t conn_state` variables with a single `app_state_t app_state = {0};` (zero-initialized, so snapshot=NULL, conn_state=CONN_DISCONNECTED).
3. Add `tab_system_t tabs;` before the main loop. Call `tab_system_init(&tabs)` after `http_client_init` but before the loop.
4. Modify the input section in the main loop. Order matters (per research Pattern 5):
   - `'q'`/`'Q'` -> quit (unchanged).
   - `KEY_RESIZE` -> `tui_resize()` (unchanged).
   - `'1'` through `'6'` -> `tab_system_activate(&tabs, ch - '1')`.
   - `'\t'` (TAB key, ASCII 9) -> `tab_system_next(&tabs)`.
   - Any other key (ch != ERR) -> `tab_system_handle_input(&tabs, ch, &app_state)`.
5. Modify the polling section for smart polling:
   - After the timer check, get `uint32_t needed = tab_system_required_endpoints(&tabs);`
   - Only poll /stats/world if `needed & ENDPOINT_STATS_WORLD`.
   - IMPORTANT (Pitfall 5 from research): Always poll /stats/world for connection health regardless of the bitmask. The simplest approach: always poll /stats/world. It is cheap (localhost, <1KB). This means: keep the existing poll as-is, just update the connection state variables to use `app_state.conn_state` and `app_state.snapshot`.
   - Alternative: Only parse and store the snapshot if `needed & ENDPOINT_STATS_WORLD`, but always make the HTTP request for connection health. Choose this approach -- it gives smart polling benefit (don't parse unnecessary data) while keeping connection health alive.
   - Actually, for Phase 02 only Overview uses /stats/world and it is the default tab. Keep it simple: always poll /stats/world (it is the only endpoint that exists right now). The bitmask infrastructure is in place for future phases to add conditional logic. For now, the code checks `needed & ENDPOINT_STATS_WORLD` and polls if set. Since Overview (default, tab 0) has this bit, it works on launch. When user switches to e.g. Entities tab (future, ENDPOINT_QUERY), the /stats/world poll stops but connection health should remain -- add a comment noting this will need a health check in future phases.
   - USE THIS APPROACH: Always poll /stats/world unconditionally (connection health + it is cheap). Only update app_state.snapshot if `needed & ENDPOINT_STATS_WORLD`. This way connection_state stays accurate on all tabs, but we skip the JSON parsing when the active tab doesn't need world stats.
6. Update `tui_render` call to `tui_render(&tabs, &app_state)`.
7. Cleanup section: add `tab_system_fini(&tabs)` BEFORE `http_client_fini(curl)` and `tui_fini()`. Order: tab_system_fini -> http_client_fini -> tui_fini (reverse of init).
8. Replace `world_snapshot_free(snapshot)` with `world_snapshot_free(app_state.snapshot)`.
  </action>
  <verify>
Build the project:
```bash
cd /home/cachy/workspaces/libs/cels && mkdir -p build && cd build && cmake .. -DCELS_DEBUG=ON -DCELS_BUILD_TOOLS=ON 2>&1 | tail -5 && make cels-debug 2>&1 | tail -20
```
Expected: compiles with 0 errors, 0 warnings.

Then verify the tab bar and switching work (if a CELS app is running):
```bash
cd /home/cachy/workspaces/libs/cels && ./run.sh debug
```
- Tab bar should be visible on row 1 with "1:Overview" highlighted.
- Press 2-6 to switch tabs; each shows "Not implemented yet" centered.
- Press TAB to cycle through tabs.
- Press q to quit cleanly.
- Header still shows connection status.
  </verify>
  <done>
The TUI launches with a 4-window layout (header, tab bar, content, footer). Tab bar shows all 6 tab labels with the active tab highlighted. Keys 1-6 directly switch tabs. TAB cycles forward (wraps). All tabs show "Not implemented yet" placeholder. Footer shows "1-6:tabs  TAB:next  q:quit". HTTP polling uses endpoint bitmask infrastructure. Connection status in header remains accurate. Clean exit on q.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --target cels-debug` completes with 0 errors
2. Launch cels-debug: tab bar is visible with 6 labeled tabs
3. Press 1 through 6: active tab highlight moves correctly
4. Press TAB repeatedly: cycles through all 6 tabs and wraps to 1
5. All placeholder tabs show "Not implemented yet" centered in content area
6. Header shows connection status (Connected if CELS app running, Disconnected otherwise)
7. Footer shows updated help text "1-6:tabs  TAB:next  q:quit"
8. Press q: clean exit, terminal restored
</verification>

<success_criteria>
- Tab vtable framework (T9) is complete: tab_def_t, tab_t, tab_system_t with 7 public API functions
- Endpoint bitmask enum is defined with 6 endpoints
- 6 tabs registered: Overview, Entities, Components, Systems, State, Performance
- Tab switching works via 1-6 keys and TAB
- Window layout is 4 windows (header + tabbar + content + footer)
- Smart polling infrastructure in place (bitmask check in main loop)
- No regressions: connection status, signal handlers, clean exit all still work
</success_criteria>

<output>
After completion, create `.planning/phases/02-tab-system-and-overview/02-01-SUMMARY.md`
</output>
