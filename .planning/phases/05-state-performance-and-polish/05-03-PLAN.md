---
phase: 05-state-performance-and-polish
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - cels-debug/src/tabs/tab_performance.c
  - cels-debug/src/tabs/tab_performance.h
  - cels-debug/src/tab_system.c
  - cels-debug/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Performance tab shows a full-width waterfall view of system execution timing"
    - "Systems are grouped by Flecs execution phase (OnLoad, OnUpdate, OnStore, etc.)"
    - "Each system shows a proportional timing bar with actual ms value"
    - "Phase headers are color-coded matching the existing phase color scheme"
    - "Frame summary shows total time, FPS, and system count at the bottom"
  artifacts:
    - path: "cels-debug/src/tabs/tab_performance.c"
      provides: "Performance tab with waterfall visualization"
      contains: "tab_performance_draw"
    - path: "cels-debug/src/tabs/tab_performance.h"
      provides: "Performance tab header"
      exports: ["tab_performance_init", "tab_performance_fini", "tab_performance_draw", "tab_performance_input"]
  key_links:
    - from: "cels-debug/src/tab_system.c"
      to: "tabs/tab_performance.h"
      via: "#include and tab_defs[3]"
      pattern: "tab_performance_init"
    - from: "cels-debug/src/tabs/tab_performance.c"
      to: "data_model.h"
      via: "system_registry_t for timing data"
      pattern: "system_registry"
---

<objective>
Implement the Performance tab with a full-width waterfall/timeline visualization showing per-system execution timing grouped by Flecs pipeline phases. This replaces the placeholder tab at index 3.

Purpose: Gives users visual insight into which systems consume the most frame time, enabling performance debugging.

Output: tab_performance.c/h with waterfall rendering, updated tab wiring to replace placeholder.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/phases/05-state-performance-and-polish/05-CONTEXT.md
@tools/cels-debug/.planning/phases/05-state-performance-and-polish/05-RESEARCH.md
@tools/cels-debug/.planning/phases/05-state-performance-and-polish/05-01-SUMMARY.md

Key source files:
@tools/cels-debug/src/tab_system.c
@tools/cels-debug/src/tab_system.h
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/data_model.h
@tools/cels-debug/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Performance tab with waterfall visualization</name>
  <files>
    cels-debug/src/tabs/tab_performance.c
    cels-debug/src/tabs/tab_performance.h
  </files>
  <action>
    1. Create tab_performance.h:
       - Include guard CELS_DEBUG_TAB_PERFORMANCE_H
       - #include "../tab_system.h"
       - Declare: tab_performance_init, tab_performance_fini, tab_performance_draw, tab_performance_input

    2. Create tab_performance.c:
       - #include "tab_performance.h", "../tui.h", "../data_model.h", "../scroll.h"
       - #include <ncurses.h>, <stdlib.h>, <string.h>, <math.h>

    3. Per-tab state (perf_state_t):
       - scroll_state_t scroll (for scrolling if more systems than screen rows)

    4. Copy PHASE_ORDER[] and phase_color_pair() static functions (same as tab_systems/tree_view -- these are small, static, acceptable duplication per project convention).

    5. The Performance tab is FULL-WIDTH (no split panel). It draws directly into the content window passed to tab_performance_draw.

    6. tab_performance_draw implementation:
       a. Read system_registry from app_state->system_registry and entity_list from app_state->entity_list
       b. If no data, show "Waiting for pipeline data..." centered and dimmed
       c. If data available:
          - Classify entities to determine system phases (same classify_node pattern as tab_systems, or just iterate entity_list and match by name with system_registry entries to get phase info from entity tags)
          - Actually, system_registry has system names but NO phase info (phase is filled by tab_ecs classify logic). The Performance tab needs phases. Options:
            (i) Copy the classification + enrichment code (has_tag, extract_pipeline_phase)
            (ii) Use system_registry entries and cross-reference with entity_list tags
          - Go with (ii): For each system in system_registry, find the matching entity in entity_list by name, read its class_detail (which contains the phase name if classified by another tab's classify step). BUT the entity_list entities are only classified when a tab that runs classify_all_entities draws. If Performance tab draws first, entities might not be classified yet.
          - SAFEST approach: Performance tab does its OWN lightweight phase detection. For each system in system_registry, scan entity_list for a matching entity by name, then extract_pipeline_phase from that entity's tags. This is self-contained.
          - Add helpers: has_tag_str(entity_node_t*, const char*), extract_phase_from_tags(entity_node_t*) -- small static functions.

       d. Build a sorted phase -> systems mapping:
          - struct perf_entry { const char *name; const char *phase; double time_ms; int color; };
          - Iterate system_registry, for each system: find phase from entity_list tags, create perf_entry
          - Group entries by phase, sort phases by PHASE_ORDER

       e. Render waterfall:
          - Clear content window with werase
          - Row 0: Title "Performance" in bold
          - Row 1: Separator line (ACS_HLINE)
          - Row 2: FPS and frame time from world_snapshot (if available)
          - Row 3: blank
          - For each phase group:
            - Phase header row: phase name (color-coded, bold), system count, total phase time
            - For each system in phase:
              - System name (left, 20 chars max, indented 4 spaces, phase-colored)
              - Proportional bar: width = (system_time / max_time) * available_cols, minimum 1 char for non-zero time
              - Time label: "X.XXms" right of bar
          - After all phases: separator line + summary row: "Total: N systems, X.Xms/frame"

       f. Bar rendering:
          - Available bar width = terminal_width - name_indent(24) - time_label_width(10) - padding(4)
          - Find max_time across ALL systems (for proportional scaling)
          - Bar character: ACS_HLINE (horizontal line) repeated, colored by phase
          - Minimum bar width of 1 for any non-zero time (avoid invisible bars from integer truncation)

       g. Scroll support:
          - Calculate total rows needed (phases + systems + headers + separators)
          - If total rows > visible height, enable scrolling with scroll_state
          - j/k scroll, PgUp/PgDn page scroll

    7. tab_performance_init: allocate perf_state_t, reset scroll
    8. tab_performance_fini: free perf_state_t
    9. tab_performance_input: handle j/k/arrows for scroll, g/G for top/bottom, PgUp/PgDn

    10. Refresh: since this is a full-width tab drawing into win_content (not split_panel), call wnoutrefresh(win) at the end of draw (same pattern as tab_overview).
  </action>
  <verify>
    Files exist: `ls cels-debug/src/tabs/tab_performance.c cels-debug/src/tabs/tab_performance.h`
    Functions declared: `grep "tab_performance_init\|tab_performance_draw" cels-debug/src/tabs/tab_performance.h`
    Waterfall rendering code: `grep "draw_timing_bar\|ACS_HLINE\|bar_width\|max_time" cels-debug/src/tabs/tab_performance.c`
  </verify>
  <done>
    tab_performance.c implements a full-width waterfall view with phase-grouped systems, proportional timing bars, and frame summary.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Performance tab into tab system</name>
  <files>
    cels-debug/src/tab_system.c
    cels-debug/CMakeLists.txt
  </files>
  <action>
    1. In tab_system.c:
       - Add: #include "tabs/tab_performance.h"
       - Update tab_defs[3] from placeholder to Performance:
         { "Performance", ENDPOINT_STATS_WORLD | ENDPOINT_STATS_PIPELINE,
           tab_performance_init, tab_performance_fini,
           tab_performance_draw, tab_performance_input }
       - If tab_placeholder.h is no longer referenced by ANY tab_defs entry, remove its #include.
         Check: After Plan 01, tab_defs uses [overview, cels, systems, performance]. If none use placeholder, remove the include.

    2. In CMakeLists.txt:
       - Add `src/tabs/tab_performance.c` to the add_executable source list
       - Remove `src/tabs/tab_placeholder.c` if no longer referenced (check if any tab_defs entry still uses tab_placeholder_*)
       - If removing tab_placeholder.c from build, the files can remain on disk as dead code (cleanup is separate concern)

    3. Build and verify.
  </action>
  <verify>
    Build: `cmake --build build 2>&1 | tail -5` -- 0 errors
    Tab wiring: `grep "tab_performance" cels-debug/src/tab_system.c` confirms Performance tab is wired
    No placeholder: `grep "placeholder" cels-debug/src/tab_system.c` should return nothing (or just comments)
  </verify>
  <done>
    Performance tab is wired at index 3, replacing the placeholder.
    All 4 tabs are now real implementations: Overview, CELS, Systems, Performance.
    No more placeholder tabs in the application.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build` succeeds with 0 errors
2. Press 4 to switch to Performance tab
3. Performance tab shows waterfall visualization with phase-grouped systems
4. Each system has a proportional timing bar with ms value
5. Phase headers are color-coded (blue for OnLoad, green for OnUpdate, etc.)
6. Bottom summary shows total system count and frame time
7. j/k scrolling works if list exceeds screen height
8. No crashes when system_registry is NULL (shows "Waiting for pipeline data...")
</verification>

<success_criteria>
- Performance tab renders phase-grouped waterfall with proportional timing bars
- Bar widths are proportional to system execution time (minimum 1 char for non-zero)
- Frame summary shows total time, FPS, system count
- Scroll works for long system lists
- No placeholder tabs remain in the application
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-performance-and-polish/05-03-SUMMARY.md`
</output>
