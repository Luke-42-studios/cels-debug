---
phase: 05-state-performance-and-polish
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - cels-debug/src/tui.h
  - cels-debug/src/tui.c
  - cels-debug/src/main.c
  - cels-debug/src/http_client.c
autonomous: true

must_haves:
  truths:
    - "Esc key returns to previous tab/position after cross-navigation jumps"
    - "Footer shows context-sensitive keybinding hints based on active tab"
    - "Auto-reconnect persists Reconnecting status until connection succeeds (no premature Disconnected)"
    - "Poll interval is configurable via command-line flag -r <ms>"
    - "Keyboard navigation is consistent: j/k scroll, Enter select, Esc back, q quit"
  artifacts:
    - path: "cels-debug/src/tui.h"
      provides: "nav_stack_t type and updated app_state_t with poll_interval_ms"
      contains: "nav_stack_t"
    - path: "cels-debug/src/tui.c"
      provides: "Context-sensitive footer hints"
      contains: "get_footer_hints"
    - path: "cels-debug/src/main.c"
      provides: "Nav stack handling, configurable poll interval, -r flag parsing"
      contains: "nav_pop"
    - path: "cels-debug/src/http_client.c"
      provides: "Fixed reconnect state machine"
      contains: "CONN_RECONNECTING"
  key_links:
    - from: "cels-debug/src/main.c"
      to: "tui.h"
      via: "nav_stack_t usage for Esc handling"
      pattern: "nav_pop\\|nav_push"
    - from: "cels-debug/src/tui.c"
      to: "tab_system.h"
      via: "tabs->active for context-sensitive hints"
      pattern: "tabs->active"
---

<objective>
Polish navigation, auto-reconnect, and configurable refresh to complete the v0.1 debugger experience. This includes: (1) Esc back-navigation stack for cross-tab jumps, (2) context-sensitive footer hint bar, (3) fixed auto-reconnect state machine, and (4) configurable poll interval via -r flag.

Purpose: These polish items transform the debugger from a functional tool into a polished one. Consistent navigation, clear status, and user-configurable refresh complete the v0.1 MVP requirements.

Output: Navigation back-stack, context-sensitive footer, fixed reconnect, configurable poll interval.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/phases/05-state-performance-and-polish/05-CONTEXT.md
@tools/cels-debug/.planning/phases/05-state-performance-and-polish/05-RESEARCH.md
@tools/cels-debug/.planning/phases/05-state-performance-and-polish/05-01-SUMMARY.md

Key source files:
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/tui.c
@tools/cels-debug/src/main.c
@tools/cels-debug/src/http_client.c
@tools/cels-debug/src/http_client.h
@tools/cels-debug/src/tab_system.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Navigation back-stack and context-sensitive footer</name>
  <files>
    cels-debug/src/tui.h
    cels-debug/src/tui.c
    cels-debug/src/main.c
  </files>
  <action>
    1. Add navigation back-stack types to tui.h:
       ```c
       #define NAV_STACK_MAX 8

       typedef struct nav_entry {
           int tab_index;              /* which tab was active */
           uint64_t entity_id;         /* entity ID for cursor restore (0 = none) */
       } nav_entry_t;

       typedef struct nav_stack {
           nav_entry_t entries[NAV_STACK_MAX];
           int top;                    /* -1 = empty */
       } nav_stack_t;
       ```

    2. Add nav_stack helper functions (can be static in main.c or inline in tui.h):
       - `static void nav_push(nav_stack_t *stack, int tab, uint64_t entity_id)` -- push entry, cap at NAV_STACK_MAX
       - `static bool nav_pop(nav_stack_t *stack, nav_entry_t *out)` -- pop entry, return false if empty
       - `static void nav_clear(nav_stack_t *stack)` -- reset stack (top = -1)

    3. Add nav_stack_t and poll_interval_ms to app_state_t in tui.h:
       ```c
       nav_stack_t nav_stack;
       int poll_interval_ms;           /* configurable refresh interval, default 500 */
       ```

    4. In main.c, initialize nav_stack:
       ```c
       app_state.nav_stack.top = -1;
       app_state.poll_interval_ms = POLL_INTERVAL_MS;  /* 500 default */
       ```

    5. In main.c input handling, integrate nav_stack:
       - When tab switch via number keys (1-4): clear nav_stack (direct tab switch = new context)
       - When tab switch via Tab key: clear nav_stack
       - When pending_tab is triggered (cross-tab navigation from Systems tab):
         BEFORE switching tabs, push current state: nav_push(&app_state.nav_stack, tabs.active, current_entity_id)
         where current_entity_id comes from the currently selected entity (if any)
       - On Esc key (27):
         If nav_stack is not empty: pop entry, switch to popped tab, set selected_entity_path to find entity by ID
         If nav_stack is empty: pass Esc to active tab's input handler (for intra-tab back-navigation like closing inspector focus)

    6. In main.c, handle Esc key:
       ```c
       if (ch == 27) {  /* Esc */
           nav_entry_t entry;
           if (nav_pop(&app_state.nav_stack, &entry)) {
               tab_system_activate(&tabs, entry.tab_index);
               /* Restore entity selection if possible */
               if (entry.entity_id != 0 && app_state.entity_list) {
                   for (int i = 0; i < app_state.entity_list->count; i++) {
                       entity_node_t *n = app_state.entity_list->nodes[i];
                       if (n->id == entry.entity_id && n->full_path) {
                           free(app_state.selected_entity_path);
                           app_state.selected_entity_path = strdup(n->full_path);
                           break;
                       }
                   }
               }
           } else {
               /* No nav history -- pass to tab */
               tab_system_handle_input(&tabs, ch, &app_state);
           }
       }
       ```
       Add this BEFORE the existing tab switch and per-tab input handling in the input section.

    7. Context-sensitive footer in tui.c:
       - Replace the hardcoded footer text with a context-sensitive function:
         ```c
         static const char *get_footer_hints(int active_tab) {
             switch (active_tab) {
             case 0:  /* Overview */
                 return "1-4:tabs  q:quit";
             case 1:  /* CELS */
                 return "1-4:tabs  jk:scroll  Enter:expand  f:anon  Esc:back  q:quit";
             case 2:  /* Systems */
                 return "1-4:tabs  jk:scroll  Enter:expand  f:anon  Esc:back  q:quit";
             case 3:  /* Performance */
                 return "1-4:tabs  jk:scroll  q:quit";
             default:
                 return "1-4:tabs  q:quit";
             }
         }
         ```
       - In tui_render, replace `mvwprintw(win_footer, 0, 1, "1-4:tabs  jk:nav  Enter:expand  f:anon  q:quit")` with:
         `mvwprintw(win_footer, 0, 1, "%s", get_footer_hints(tabs->active))`

    8. In main.c, replace hardcoded POLL_INTERVAL_MS usage:
       - Change `if (now - last_poll >= POLL_INTERVAL_MS)` to `if (now - last_poll >= app_state.poll_interval_ms)`
       - This allows runtime configurability (set by -r flag, see Task 2)
  </action>
  <verify>
    Build: `cmake --build build 2>&1 | tail -5`
    Nav stack types: `grep "nav_stack_t\|nav_push\|nav_pop" cels-debug/src/tui.h cels-debug/src/main.c`
    Footer function: `grep "get_footer_hints" cels-debug/src/tui.c`
    Poll interval configurable: `grep "poll_interval_ms" cels-debug/src/main.c`
  </verify>
  <done>
    Esc pops navigation back-stack (returns to previous tab/position).
    Direct tab switches (1-4, Tab) clear the nav stack.
    Cross-tab navigation pushes to nav stack before switching.
    Footer shows context-sensitive hints per active tab.
    Poll interval uses app_state field instead of hardcoded constant.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auto-reconnect fix and configurable poll interval</name>
  <files>
    cels-debug/src/http_client.c
    cels-debug/src/main.c
  </files>
  <action>
    1. Fix auto-reconnect state machine in http_client.c:
       - Current bug: connection_state_update transitions RECONNECTING -> DISCONNECTED on the second failed poll.
       - Fix: Once connected (or reconnecting), stay in RECONNECTING on any failure. Only go to DISCONNECTED if we've NEVER connected.
       - Replace the current function:
         ```c
         connection_state_t connection_state_update(connection_state_t current, int http_status) {
             if (http_status == 200) {
                 return CONN_CONNECTED;
             }
             /* Once we've ever connected, always show Reconnecting on failure */
             if (current == CONN_CONNECTED || current == CONN_RECONNECTING) {
                 return CONN_RECONNECTING;
             }
             /* Never connected yet -- stay disconnected */
             return CONN_DISCONNECTED;
         }
         ```
       - This is a one-line change: the condition changes from `current == CONN_CONNECTED` to `current == CONN_CONNECTED || current == CONN_RECONNECTING`.

    2. Update the comment in http_client.h to reflect new behavior:
       - Change: "status != 200 && was DISCONNECTED/RECONNECTING -> DISCONNECTED"
       - To: "status != 200 && was CONNECTED/RECONNECTING -> RECONNECTING (silent retry)"
       - Add: "status != 200 && never connected -> DISCONNECTED"

    3. Add -r <ms> command-line flag parsing in main.c:
       - Parse argc/argv before the main loop:
         ```c
         int poll_interval = POLL_INTERVAL_MS;  /* 500 default */
         for (int i = 1; i < argc; i++) {
             if (strcmp(argv[i], "-r") == 0 && i + 1 < argc) {
                 poll_interval = atoi(argv[++i]);
                 if (poll_interval < 100) poll_interval = 100;    /* minimum 100ms */
                 if (poll_interval > 5000) poll_interval = 5000;  /* maximum 5s */
             }
         }
         app_state.poll_interval_ms = poll_interval;
         ```
       - Remove the `(void)argc; (void)argv;` lines since we now use them.
       - Keep POLL_INTERVAL_MS as the default value constant.
  </action>
  <verify>
    Build: `cmake --build build 2>&1 | tail -5`
    Reconnect fix: `grep "CONN_RECONNECTING" cels-debug/src/http_client.c` -- should show the || condition
    CLI flag: `grep '"-r"' cels-debug/src/main.c`
    Interval bounds: `grep "poll_interval.*100\|poll_interval.*5000" cels-debug/src/main.c`
  </verify>
  <done>
    Auto-reconnect stays in RECONNECTING state until successful response (never prematurely shows Disconnected).
    Command-line flag -r <ms> configures poll interval (100-5000ms range, 500ms default).
    Header status transitions are clean: Connected -> Reconnecting... -> Connected.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build` succeeds with 0 errors
2. Cross-tab navigation: In Systems tab, press Enter on matched entity -> switches to CELS tab. Press Esc -> returns to Systems tab.
3. Direct tab switch (press 1-4) does NOT push to nav stack -- Esc does nothing (or passes to tab)
4. Footer changes per tab: Overview shows minimal hints, CELS/Systems show full navigation hints
5. Auto-reconnect: Start without CELS app running -> shows "Disconnected". Start CELS app -> shows "Connected". Kill CELS app -> shows "Reconnecting..." indefinitely (not "Disconnected"). Restart CELS app -> shows "Connected" again.
6. CLI: `./cels-debug -r 200` polls at 200ms. `./cels-debug` defaults to 500ms.
</verification>

<success_criteria>
- Esc back-navigation works for cross-tab jumps (push on navigate, pop on Esc)
- Footer hints are context-sensitive per active tab
- Auto-reconnect stays in Reconnecting state (never premature Disconnected)
- Poll interval configurable via -r flag (100-5000ms range)
- j/k, Enter, Esc, q consistent across all tabs
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-performance-and-polish/05-04-SUMMARY.md`
</output>
