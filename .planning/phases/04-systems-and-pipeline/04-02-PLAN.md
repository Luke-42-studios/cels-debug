---
phase: 04-systems-and-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - tools/cels-debug/src/tree_view.h
  - tools/cels-debug/src/tree_view.c
  - tools/cels-debug/src/tabs/tab_ecs.c
autonomous: true

must_haves:
  truths:
    - "Systems section in CELS-C tree shows systems grouped under phase sub-headers (OnUpdate, OnStore, etc.)"
    - "Phase sub-headers are collapsible (Enter toggles), start expanded"
    - "Empty phase groups are hidden -- only phases with registered systems appear"
    - "Each system row shows name, color-coded phase tag, and entity match count"
    - "Disabled systems render in dimmed text"
    - "Inspector shows pipeline visualization when a phase sub-header is selected"
    - "Inspector shows summary stats when the Systems CELS-C header is selected"
  artifacts:
    - path: "tools/cels-debug/src/tree_view.h"
      provides: "Extended display_row_t with phase_group field, phase collapse state in tree_view_t"
      contains: "phase_group"
    - path: "tools/cels-debug/src/tree_view.c"
      provides: "Phase sub-header rendering, phase grouping in rebuild, phase collapse toggling"
      contains: "phase_group"
    - path: "tools/cels-debug/src/tabs/tab_ecs.c"
      provides: "System enrichment from pipeline stats, pipeline viz inspector, systems summary inspector"
      contains: "pipeline"
  key_links:
    - from: "tools/cels-debug/src/tabs/tab_ecs.c"
      to: "system_registry_t"
      via: "enrichment merges pipeline stats into entity nodes"
      pattern: "system_registry"
    - from: "tools/cels-debug/src/tree_view.c"
      to: "display_row_t.phase_group"
      via: "phase sub-headers inserted during rebuild"
      pattern: "phase_group"
    - from: "tools/cels-debug/src/tabs/tab_ecs.c"
      to: "tree_view phase sub-header selection"
      via: "inspector checks if selected row is phase sub-header"
      pattern: "phase_group.*>=.*0"
---

<objective>
Add phase sub-headers to the tree view for grouping systems by execution phase, enrich system nodes with pipeline stats data, and render pipeline visualization + summary stats in the inspector panel.

Purpose: This makes the Systems section usable -- systems grouped by phase with timing/match data, plus pipeline overview in inspector.
Output: Fully functional Systems section in CELS-C tree with phase grouping and two new inspector branches (pipeline viz + summary).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/STATE.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-RESEARCH.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-CONTEXT.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-01-SUMMARY.md

@tools/cels-debug/src/tree_view.h
@tools/cels-debug/src/tree_view.c
@tools/cels-debug/src/tabs/tab_ecs.c
@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/tui.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tree view phase sub-headers and enriched system rendering</name>
  <files>
    tools/cels-debug/src/tree_view.h
    tools/cels-debug/src/tree_view.c
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
**Canonical phase ordering** -- used by both tree_view.c and tab_ecs.c:

Define a static const array in tree_view.c:
```c
/* Canonical Flecs pipeline phase execution order */
static const char *PHASE_ORDER[] = {
    "OnStart", "OnLoad", "PostLoad", "PreUpdate", "OnUpdate",
    "OnValidate", "PostUpdate", "PreStore", "OnStore", "PostFrame",
};
static const int PHASE_ORDER_COUNT = 10;
```

**tree_view.h** -- Extend display_row_t:
```c
typedef struct display_row {
    entity_node_t *node;   /* Non-NULL = entity row, NULL = header */
    int section_idx;       /* Which CELS-C section this belongs to */
    int phase_group;       /* -1 = section/entity row, >=0 = phase sub-header index */
} display_row_t;
```

Add phase collapse state to tree_view_t -- add a dynamic array since phase count varies:
```c
typedef struct tree_view {
    display_row_t *rows;
    int row_count;
    scroll_state_t scroll;
    bool show_anonymous;
    uint64_t prev_selected_id;

    /* CELS-C section state */
    bool section_collapsed[ENTITY_CLASS_COUNT];
    int section_item_count[ENTITY_CLASS_COUNT];

    /* Phase sub-header state (for Systems section) */
    char **phase_names;           /* unique phase names in execution order */
    int *phase_system_counts;     /* system count per phase */
    bool *phase_collapsed;        /* collapse state per phase */
    int phase_count;              /* number of active phases */
} tree_view_t;
```

Add a new public function to populate phase data before rebuild:
```c
/* Set phase grouping data for Systems section. Called before rebuild.
 * tree_view does NOT own these strings -- caller must keep them valid. */
void tree_view_set_phases(tree_view_t *tv, char **phase_names,
                          int *phase_system_counts, int phase_count);
```

**tree_view.c** -- Changes:

1. `tree_view_init()`: Initialize phase fields to NULL/0. phase_collapsed starts as NULL (allocated on first set_phases call).

2. `tree_view_fini()`: Free phase_names array (but NOT the strings themselves -- they're owned by system_registry or are static). Free phase_system_counts. Free phase_collapsed.

WAIT -- to keep ownership clean, tree_view_set_phases should strdup the phase names so tree_view owns them. Then tree_view_fini frees them.

Revised: `tree_view_set_phases()`:
- Free old phase_names strings, then free arrays
- Allocate new arrays: phase_names (char**), phase_system_counts (int*), phase_collapsed (bool*)
- strdup each phase name
- Copy counts
- Preserve existing collapse state: if a phase name existed before with same name, keep its collapsed state. Otherwise start expanded (false = not collapsed).

3. `tree_view_rebuild_visible()`: Change the Systems section (ENTITY_CLASS_SYSTEM) build logic:

For ALL sections EXCEPT ENTITY_CLASS_SYSTEM, behavior is unchanged: add header row, then if not collapsed, DFS collect roots.

For ENTITY_CLASS_SYSTEM: add the section header row. If not collapsed:
- For each phase (in tv->phase_names order):
  - If phase_system_counts[p] == 0, skip (hidden empty groups)
  - Add a phase sub-header row: `node=NULL, section_idx=ENTITY_CLASS_SYSTEM, phase_group=p`
  - If phase is not collapsed (!tv->phase_collapsed[p]):
    - DFS collect only system root nodes whose class_detail matches this phase name
- After all known phases, collect any remaining system nodes whose class_detail does NOT match any phase name (unknown/custom phases) -- group them at the end under a "Custom" sub-header if any exist.

IMPORTANT: Max rows calculation needs updating. Add `tv->phase_count + 1` (for potential "Custom" group) to the max_rows allocation.

4. `tree_view_toggle_expand()`: Extend the NULL-node case. Currently it checks `!cur->node` and toggles section collapse. Now also check `cur->phase_group >= 0`:
- If `phase_group >= 0`: toggle `tv->phase_collapsed[phase_group]`
- If `phase_group == -1`: toggle section collapse (existing behavior)

5. Rendering in `tree_view_render()`:

Add a new static function `draw_phase_subheader()`:
```c
static void draw_phase_subheader(WINDOW *win, int row, int max_cols,
                                  const char *phase_name, int sys_count,
                                  bool collapsed, bool is_cursor, int color_pair) {
    if (is_cursor) {
        wattron(win, A_REVERSE);
        wmove(win, row, 1);
        for (int c = 0; c < max_cols; c++) waddch(win, ' ');
    }

    /* Indented under section header */
    mvwprintw(win, row, 3, "%s ", collapsed ? ">" : "v");

    /* Phase name in color */
    wattron(win, COLOR_PAIR(color_pair) | A_BOLD);
    wprintw(win, "%s", phase_name);
    wattroff(win, COLOR_PAIR(color_pair) | A_BOLD);

    /* System count */
    wattron(win, A_DIM);
    wprintw(win, " (%d)", sys_count);
    wattroff(win, A_DIM);

    if (is_cursor) wattroff(win, A_REVERSE);
}
```

Add a static helper to map phase name to color pair:
```c
static int phase_color_pair(const char *phase) {
    if (!phase) return CP_PHASE_CUSTOM;
    if (strcmp(phase, "OnLoad") == 0)      return CP_PHASE_ONLOAD;
    if (strcmp(phase, "PostLoad") == 0)    return CP_PHASE_POSTLOAD;
    if (strcmp(phase, "PreUpdate") == 0)   return CP_PHASE_PREUPDATE;
    if (strcmp(phase, "OnUpdate") == 0)    return CP_PHASE_ONUPDATE;
    if (strcmp(phase, "OnValidate") == 0)  return CP_PHASE_ONVALIDATE;
    if (strcmp(phase, "PostUpdate") == 0)  return CP_PHASE_POSTUPDATE;
    if (strcmp(phase, "PreStore") == 0)    return CP_PHASE_PRESTORE;
    if (strcmp(phase, "OnStore") == 0)     return CP_PHASE_ONSTORE;
    if (strcmp(phase, "PostFrame") == 0)   return CP_PHASE_POSTFRAME;
    if (strcmp(phase, "OnStart") == 0)     return CP_PHASE_ONLOAD; /* reuse blue */
    return CP_PHASE_CUSTOM;
}
```

In the main render loop, when `!dr->node`:
- If `dr->phase_group >= 0`: call `draw_phase_subheader()` with the phase name from tv->phase_names[dr->phase_group], count from tv->phase_system_counts[dr->phase_group], collapse from tv->phase_collapsed[dr->phase_group]
- If `dr->phase_group == -1`: existing `draw_section_header()` call

For entity rows in the Systems section: modify entity rendering to show enriched info. When `node->entity_class == ENTITY_CLASS_SYSTEM`, the right-aligned info should show:
- Phase tag in color: `[OnUpdate]` using phase_color_pair(node->class_detail)
- Match count: `(42)` after the phase tag
- If disabled: render entire row with A_DIM attribute

The match count and disabled status come from enrichment (see tab_ecs.c changes below). Since entity_node_t doesn't have these fields directly, use the class_detail field format. ALTERNATIVE: Add two small fields to entity_node_t. Actually NO -- entity_node_t is the entity list data model and shouldn't hold pipeline stats. Instead, the tree_view_render for system rows should just show `[phase]` from class_detail as it already does. The match count display requires passing system_registry data to the render function.

SIMPLEST APPROACH: Extend `class_detail` in tab_ecs.c enrichment to include match count, e.g. `"OnUpdate (42)"`. Then tree_view_render shows `[OnUpdate (42)]` using existing code path. For disabled status, add a single `bool disabled` field to entity_node_t (lightweight addition).

Add to entity_node_t in data_model.h:
```c
bool disabled;  /* system disabled status from /stats/pipeline */
```

In tree_view_render, for entity rows: if `node->disabled`, wrap the row in A_DIM:
```c
if (node->disabled) wattron(win, A_DIM);
// ... existing render code ...
if (node->disabled) wattroff(win, A_DIM);
```

For the right-aligned class_detail rendering for systems, use phase_color_pair instead of CP_COMPONENT_HEADER:
```c
if (node->entity_class == ENTITY_CLASS_SYSTEM && node->class_detail) {
    /* Color-code by phase */
    int cp = phase_color_pair(node->class_detail);
    // ... render [class_detail] with COLOR_PAIR(cp) instead of CP_COMPONENT_HEADER
}
```

Wait, class_detail for systems currently holds the phase name (e.g., "OnUpdate"). If we change it to "OnUpdate (42)", the phase_color_pair lookup breaks. Better approach:

Keep class_detail as just the phase name. Add a separate display in the tree for match count. In tree_view_render, for ENTITY_CLASS_SYSTEM nodes specifically:
- Render `[phase]` in phase color (from class_detail)
- Then render `(N)` for match count after it
- If disabled, dim the whole row

To pass the match count, the simplest is to add `int system_match_count` to entity_node_t. It's only populated for system entities. This is similar to how class_detail is only meaningful for certain classes.

Add to entity_node_t in data_model.h:
```c
int system_match_count;   /* match count from pipeline stats, 0 if not a system */
bool disabled;            /* system disabled from pipeline stats */
```

These are zero-initialized by calloc.

**tab_ecs.c** -- Add system enrichment function and phase data extraction:

Add a new static function `enrich_systems_with_pipeline()`:
```c
/* Enrich system entity nodes with data from pipeline stats.
 * Matches by leaf name (fast, sufficient for small apps).
 * Also builds the phase list for tree_view phase sub-headers. */
static void enrich_systems_with_pipeline(entity_list_t *list,
                                          system_registry_t *reg,
                                          tree_view_t *tree) {
    if (!list || !reg || reg->count == 0) {
        tree_view_set_phases(tree, NULL, NULL, 0);
        return;
    }

    /* Build ordered phase list from system entities (using entity tags, not pipeline) */
    /* Collect unique phase names from roots classified as SYSTEM */
    char *found_phases[32];   /* static max, practical limit */
    int found_counts[32];
    int found_count = 0;

    for (int i = 0; i < list->root_count; i++) {
        entity_node_t *node = list->roots[i];
        if (node->entity_class != ENTITY_CLASS_SYSTEM) continue;
        if (!node->class_detail) continue;

        /* Check if phase already in list */
        bool exists = false;
        for (int p = 0; p < found_count; p++) {
            if (strcmp(found_phases[p], node->class_detail) == 0) {
                found_counts[p]++;
                exists = true;
                break;
            }
        }
        if (!exists && found_count < 32) {
            found_phases[found_count] = node->class_detail;
            found_counts[found_count] = 1;
            found_count++;
        }
    }

    /* Sort phases by canonical order */
    /* Use PHASE_ORDER index as sort key. Unknown phases go to end. */
    /* Simple insertion sort (max 32 elements) */
    for (int i = 1; i < found_count; i++) {
        char *phase = found_phases[i];
        int count = found_counts[i];
        int order_i = PHASE_ORDER_COUNT; /* default: end */
        for (int k = 0; k < PHASE_ORDER_COUNT; k++) {
            if (strcmp(phase, PHASE_ORDER[k]) == 0) { order_i = k; break; }
        }
        int j = i - 1;
        while (j >= 0) {
            int order_j = PHASE_ORDER_COUNT;
            for (int k = 0; k < PHASE_ORDER_COUNT; k++) {
                if (strcmp(found_phases[j], PHASE_ORDER[k]) == 0) { order_j = k; break; }
            }
            if (order_j > order_i) {
                found_phases[j + 1] = found_phases[j];
                found_counts[j + 1] = found_counts[j];
                j--;
            } else break;
        }
        found_phases[j + 1] = phase;
        found_counts[j + 1] = count;
    }

    tree_view_set_phases(tree, found_phases, found_counts, found_count);

    /* Enrich each system entity with pipeline stats (match by leaf name) */
    for (int i = 0; i < list->root_count; i++) {
        entity_node_t *node = list->roots[i];
        if (node->entity_class != ENTITY_CLASS_SYSTEM) continue;
        if (!node->name) continue;

        for (int s = 0; s < reg->count; s++) {
            if (reg->systems[s].name &&
                strcmp(reg->systems[s].name, node->name) == 0) {
                node->system_match_count = reg->systems[s].matched_entity_count;
                node->disabled = reg->systems[s].disabled;
                break;
            }
        }
    }
}
```

Note: The PHASE_ORDER array needs to be accessible from tab_ecs.c. Options:
- Duplicate in tab_ecs.c (simple, acceptable for a 10-element array)
- Move to a shared header

Best: Define PHASE_ORDER in tab_ecs.c since that's where the sorting logic lives. tree_view.c uses its own copy for phase_color_pair if needed, or just use it for rendering. Actually tree_view.c doesn't need the ordering -- it renders whatever order tree_view_set_phases provides. So PHASE_ORDER only needed in tab_ecs.c.

Call `enrich_systems_with_pipeline()` in `tab_ecs_draw()`, after `classify_all_entities()` and `annotate_component_entities()`, before `tree_view_rebuild_visible()`:
```c
classify_all_entities(state->entity_list);
annotate_component_entities(state->entity_list, state->component_registry);
enrich_systems_with_pipeline(state->entity_list, state->system_registry, &es->tree);
tree_view_rebuild_visible(&es->tree, state->entity_list);
```

IMPORTANT: The `enrich_systems_with_pipeline` function needs access to app_state_t for system_registry. Cast from the const void* state parameter (already done for entity_list). The function signature above takes system_registry_t* directly.
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with a CELS app. Navigate to ECS tab. Expand Systems section. Verify:
1. Phase sub-headers appear (OnUpdate, OnStore, etc.) with system counts
2. Enter on phase sub-header toggles collapse
3. System names show with color-coded `[Phase]` tags
4. Match counts appear as `(N)` on system rows
5. Disabled systems (if any) appear dimmed
6. Empty phases are not shown
  </verify>
  <done>
Tree view extended with phase sub-header rows. Systems section groups systems under collapsible phase headers ordered by Flecs execution order. System entity nodes enriched with match count and disabled status from pipeline stats. Phase tags color-coded by execution phase. Disabled systems render dimmed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Inspector branches for pipeline visualization and systems summary</name>
  <files>
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
Add two new inspector rendering branches in `tab_ecs_draw()`. These go in the right panel rendering section, BEFORE the existing `sel && sel->entity_class == ENTITY_CLASS_COMPONENT` check.

The inspector dispatch logic should now be:

```c
/* Right panel: context-sensitive inspector */
entity_node_t *sel = tree_view_selected(&es->tree);
display_row_t *cur_row = NULL;
if (es->tree.rows && es->tree.scroll.cursor >= 0 &&
    es->tree.scroll.cursor < es->tree.row_count) {
    cur_row = &es->tree.rows[es->tree.scroll.cursor];
}
WINDOW *rwin = es->panel.right;
int rh = getmaxy(rwin) - 2;
int rw = getmaxx(rwin) - 2;

if (cur_row && !cur_row->node && cur_row->section_idx == ENTITY_CLASS_SYSTEM) {
    if (cur_row->phase_group >= 0) {
        /* --- Branch: Phase sub-header selected -> Pipeline visualization --- */
        draw_pipeline_viz(rwin, rh, rw, &es->tree, cur_row->phase_group, state);
    } else {
        /* --- Branch: Systems section header selected -> Summary stats --- */
        draw_systems_summary(rwin, rh, rw, state);
    }
} else if (sel && sel->entity_class == ENTITY_CLASS_COMPONENT) {
    /* ... existing component inspector ... */
} else if (sel && state->entity_detail) {
    /* ... existing entity detail inspector ... */
} else if (!sel) {
    /* ... existing "select an entity" placeholder ... */
} else {
    /* ... existing "Loading..." placeholder ... */
}
```

Implement `draw_pipeline_viz()`:
```c
static void draw_pipeline_viz(WINDOW *rwin, int rh, int rw,
                               tree_view_t *tree, int selected_phase,
                               const app_state_t *state) {
    /* Title */
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, 1, 1, "Pipeline Execution Order");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);

    /* Separator */
    wattron(rwin, A_DIM);
    wmove(rwin, 2, 1);
    for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
    wattroff(rwin, A_DIM);

    int row = 4;  /* Start rendering phases */

    /* Box-drawing characters */
    /* U+2502 vertical line, U+2193 downward arrow */
    #define PIPE_VERT  "\xe2\x94\x82"
    #define PIPE_ARROW "\xe2\x86\x93"

    double total_time = 0.0;
    int total_systems = 0;

    for (int p = 0; p < tree->phase_count; p++) {
        if (row >= rh) break;

        bool is_selected = (p == selected_phase);
        int cp = phase_color_pair(tree->phase_names[p]);

        if (is_selected) wattron(rwin, A_REVERSE);

        /* Phase name */
        wattron(rwin, COLOR_PAIR(cp) | A_BOLD);
        mvwprintw(rwin, row, 3, "%-14s", tree->phase_names[p]);
        wattroff(rwin, COLOR_PAIR(cp) | A_BOLD);

        /* System count */
        int sys_count = tree->phase_system_counts[p];
        wprintw(rwin, " %d system%s", sys_count, sys_count == 1 ? "" : "s");
        total_systems += sys_count;

        /* Timing data (sum all systems in this phase from pipeline stats) */
        if (state->system_registry) {
            double phase_time = 0.0;
            for (int s = 0; s < state->system_registry->count; s++) {
                /* Match systems whose phase matches this phase name.
                 * Phase comes from entity tags, so look up in entity_list. */
                system_info_t *si = &state->system_registry->systems[s];
                /* Find the entity node for this system to get its phase */
                if (state->entity_list) {
                    for (int e = 0; e < state->entity_list->root_count; e++) {
                        entity_node_t *en = state->entity_list->roots[e];
                        if (en->entity_class == ENTITY_CLASS_SYSTEM &&
                            en->name && si->name &&
                            strcmp(en->name, si->name) == 0 &&
                            en->class_detail &&
                            strcmp(en->class_detail, tree->phase_names[p]) == 0) {
                            phase_time += si->time_spent_ms;
                            break;
                        }
                    }
                }
            }
            if (phase_time > 0.0) {
                wprintw(rwin, "   %.1fms", phase_time);
                total_time += phase_time;
            }
        }

        if (is_selected) wattroff(rwin, A_REVERSE);

        row++;

        /* Draw connector to next phase (if not last) */
        if (p < tree->phase_count - 1 && row + 1 < rh) {
            wattron(rwin, A_DIM);
            mvwprintw(rwin, row, 6, PIPE_VERT);
            row++;
            mvwprintw(rwin, row, 6, PIPE_ARROW);
            row++;
            wattroff(rwin, A_DIM);
        }
    }

    /* Total summary at bottom */
    row += 1;
    if (row < rh) {
        wattron(rwin, A_DIM);
        wmove(rwin, row, 1);
        for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
        wattroff(rwin, A_DIM);
        row++;
    }
    if (row < rh) {
        mvwprintw(rwin, row, 3, "Total: %d system%s",
                  total_systems, total_systems == 1 ? "" : "s");
        if (total_time > 0.0) {
            wprintw(rwin, ", %.1fms/frame", total_time);
        }
    }
}
```

Implement `draw_systems_summary()`:
```c
static void draw_systems_summary(WINDOW *rwin, int rh, int rw,
                                  const app_state_t *state) {
    /* Title */
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, 1, 1, "Systems Overview");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);

    /* Separator */
    wattron(rwin, A_DIM);
    wmove(rwin, 2, 1);
    for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
    wattroff(rwin, A_DIM);

    if (!state->entity_list) {
        wattron(rwin, A_DIM);
        mvwprintw(rwin, 4, 3, "Waiting for data...");
        wattroff(rwin, A_DIM);
        return;
    }

    /* Count totals from entity list */
    int total = 0, enabled = 0, disabled = 0;
    for (int i = 0; i < state->entity_list->root_count; i++) {
        entity_node_t *n = state->entity_list->roots[i];
        if (n->entity_class != ENTITY_CLASS_SYSTEM) continue;
        total++;
        if (n->disabled) disabled++;
        else enabled++;
    }

    int row = 4;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 3, "Total Systems");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    mvwprintw(rwin, row, 20, "%d", total);
    wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));

    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 3, "Enabled");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    wattron(rwin, COLOR_PAIR(CP_CONNECTED));
    mvwprintw(rwin, row, 20, "%d", enabled);
    wattroff(rwin, COLOR_PAIR(CP_CONNECTED));

    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 3, "Disabled");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    if (disabled > 0) {
        wattron(rwin, COLOR_PAIR(CP_DISCONNECTED));
        mvwprintw(rwin, row, 20, "%d", disabled);
        wattroff(rwin, COLOR_PAIR(CP_DISCONNECTED));
    } else {
        wattron(rwin, A_DIM);
        mvwprintw(rwin, row, 20, "0");
        wattroff(rwin, A_DIM);
    }

    /* Phase distribution */
    row += 2;
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, row, 1, "Phase Distribution");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    row++;

    /* Use phase data from tree view if available */
    /* Iterate entity list and count per-phase */
    char *phases[32];
    int pcounts[32];
    int pcount = 0;

    for (int i = 0; i < state->entity_list->root_count; i++) {
        entity_node_t *n = state->entity_list->roots[i];
        if (n->entity_class != ENTITY_CLASS_SYSTEM) continue;
        const char *ph = n->class_detail ? n->class_detail : "Unknown";
        bool found = false;
        for (int p = 0; p < pcount; p++) {
            if (strcmp(phases[p], ph) == 0) { pcounts[p]++; found = true; break; }
        }
        if (!found && pcount < 32) {
            phases[pcount] = (char *)ph;
            pcounts[pcount] = 1;
            pcount++;
        }
    }

    for (int p = 0; p < pcount && row < rh; p++) {
        int cp = phase_color_pair(phases[p]);
        wattron(rwin, COLOR_PAIR(cp));
        mvwprintw(rwin, row, 3, "%-14s", phases[p]);
        wattroff(rwin, COLOR_PAIR(cp));
        wprintw(rwin, " %d", pcounts[p]);
        row++;
    }
}
```

NOTE: `phase_color_pair()` helper is defined in tree_view.c but needed in tab_ecs.c too. Options:
1. Duplicate in tab_ecs.c (simple, small function)
2. Move to tui.h as static inline or to a shared file

Best: Duplicate in tab_ecs.c. It's a simple lookup function, keeping it local avoids header changes. Add `#include "../tui.h"` is already included.

IMPORTANT: Initialize `phase_group = -1` for all rows in add_header_row and dfs_collect in tree_view.c. The new `display_row_t` has a `phase_group` field that must be -1 for non-phase rows. Use: `tv->rows[tv->row_count].phase_group = -1;` in both `add_header_row()` and `dfs_collect()`.
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with CELS app. Navigate to ECS tab, expand Systems section:
1. Select "Systems" header -> inspector shows summary (total, enabled, disabled, phase distribution)
2. Select a phase sub-header (e.g., OnUpdate) -> inspector shows pipeline visualization with phases connected by vertical lines and arrows, selected phase highlighted
3. Timing data appears next to phases if pipeline stats are available
4. Total line at bottom of pipeline viz shows aggregate count and timing
  </verify>
  <done>
Inspector panel renders pipeline visualization when phase sub-header is selected (vertical flow with box-drawing connectors, color-coded phases, timing data, highlighted selected phase). Inspector renders systems summary when Systems header is selected (total/enabled/disabled counts, phase distribution). Both branches use live data from entity classification and pipeline stats.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero warnings
2. Systems section shows phase sub-headers in canonical execution order
3. Phase sub-headers are collapsible, start expanded
4. Empty phases hidden
5. System rows show color-coded phase tags and match counts
6. Disabled systems are dimmed
7. Inspector: phase header -> pipeline viz; Systems header -> summary stats
8. Navigation through phase headers works (j/k, Enter to collapse)
</verification>

<success_criteria>
- display_row_t extended with phase_group field
- tree_view_t tracks phase collapse state
- tree_view_rebuild_visible groups ENTITY_CLASS_SYSTEM nodes under phase sub-headers
- Phase ordering follows Flecs canonical order (OnStart, OnLoad, ... PostFrame)
- Pipeline visualization uses box-drawing characters with vertical flow
- Systems summary shows total/enabled/disabled counts and phase distribution
- All phase names color-coded (OnUpdate=green, OnStore=red, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/04-systems-and-pipeline/04-02-SUMMARY.md`
</output>
