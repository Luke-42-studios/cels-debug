---
phase: 04-systems-and-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tools/cels-debug/src/data_model.h
  - tools/cels-debug/src/data_model.c
  - tools/cels-debug/src/json_parser.h
  - tools/cels-debug/src/json_parser.c
  - tools/cels-debug/src/tui.h
  - tools/cels-debug/src/tui.c
  - tools/cels-debug/src/main.c
  - tools/cels-debug/src/tab_system.c
autonomous: true

must_haves:
  truths:
    - "Pipeline stats data is fetched from /stats/pipeline every poll cycle when ECS tab is active"
    - "System info (name, disabled, match count, timing) is parsed from pipeline stats JSON"
    - "Phase color pairs are initialized and available for system rendering"
  artifacts:
    - path: "tools/cels-debug/src/data_model.h"
      provides: "system_info_t and system_registry_t structs"
      contains: "system_info_t"
    - path: "tools/cels-debug/src/data_model.c"
      provides: "system_registry lifecycle functions"
      contains: "system_registry_free"
    - path: "tools/cels-debug/src/json_parser.h"
      provides: "json_parse_pipeline_stats declaration"
      contains: "json_parse_pipeline_stats"
    - path: "tools/cels-debug/src/json_parser.c"
      provides: "Pipeline stats JSON parser implementation"
      contains: "json_parse_pipeline_stats"
    - path: "tools/cels-debug/src/tui.h"
      provides: "Phase color pair defines and system_registry_t* in app_state_t"
      contains: "CP_PHASE_ONUPDATE"
    - path: "tools/cels-debug/src/tui.c"
      provides: "Phase color pair init_pair calls"
      contains: "CP_PHASE_ONUPDATE"
    - path: "tools/cels-debug/src/main.c"
      provides: "Pipeline stats polling and cleanup"
      contains: "stats/pipeline"
  key_links:
    - from: "tools/cels-debug/src/main.c"
      to: "json_parse_pipeline_stats"
      via: "polling loop calls parser"
      pattern: "json_parse_pipeline_stats"
    - from: "tools/cels-debug/src/tab_system.c"
      to: "ENDPOINT_STATS_PIPELINE"
      via: "ECS tab requests pipeline endpoint"
      pattern: "ENDPOINT_STATS_PIPELINE"
    - from: "tools/cels-debug/src/main.c"
      to: "system_registry_free"
      via: "cleanup on exit"
      pattern: "system_registry_free"
---

<objective>
Add the data pipeline for system/pipeline stats: data model structs, JSON parser for /stats/pipeline, polling in main loop, and phase color pairs.

Purpose: This is the data foundation for Phase 04. Without parsed pipeline stats in app_state, the tree view and inspector cannot display system information.
Output: system_registry_t* populated in app_state every poll cycle, phase color pairs ready for rendering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/STATE.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-RESEARCH.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-CONTEXT.md

@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/data_model.c
@tools/cels-debug/src/json_parser.h
@tools/cels-debug/src/json_parser.c
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/tui.c
@tools/cels-debug/src/main.c
@tools/cels-debug/src/tab_system.c
@tools/cels-debug/src/tab_system.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Data model + JSON parser for pipeline stats</name>
  <files>
    tools/cels-debug/src/data_model.h
    tools/cels-debug/src/data_model.c
    tools/cels-debug/src/json_parser.h
    tools/cels-debug/src/json_parser.c
  </files>
  <action>
**data_model.h** -- Add after component_registry_t, before function declarations:

```c
// Single system info (parsed from /stats/pipeline + entity tags)
typedef struct system_info {
    char *name;              // leaf name (e.g., "MovementSystem")
    char *full_path;         // dot-separated path from pipeline stats
    char *phase;             // phase name (e.g., "OnUpdate") -- filled by tab_ecs classify
    bool disabled;           // from pipeline stats
    int matched_entity_count; // latest gauge value
    int matched_table_count;  // latest gauge value
    double time_spent_ms;    // latest gauge value, converted to ms
} system_info_t;

// All systems from one /stats/pipeline poll
typedef struct system_registry {
    system_info_t *systems;
    int count;
} system_registry_t;
```

Add lifecycle functions:
```c
system_registry_t *system_registry_create(void);
void system_registry_free(system_registry_t *reg);
```

**data_model.c** -- Add system_registry lifecycle:
- `system_registry_create()`: calloc, return
- `system_registry_free()`: for each system, free name, full_path, phase strings. free systems array. free reg.

**json_parser.h** -- Add declaration:
```c
// Parse /stats/pipeline JSON response into a system_registry_t.
// The response is a JSON array alternating system entries (have "name") and
// sync point entries (have "system_count"). Only system entries are parsed.
// Returns a newly allocated registry on success, NULL on parse failure.
// Caller owns the returned registry and must call system_registry_free().
system_registry_t *json_parse_pipeline_stats(const char *json, size_t len);
```

**json_parser.c** -- Add `json_parse_pipeline_stats()`:

Add a static helper (reuse existing pattern from extract_latest_gauge):
```c
static double extract_pipeline_gauge(yyjson_val *obj, const char *field) {
    yyjson_val *metric = yyjson_obj_get(obj, field);
    if (!metric) return 0.0;
    yyjson_val *avg = yyjson_obj_get(metric, "avg");
    if (!avg || !yyjson_is_arr(avg)) return 0.0;
    size_t count = yyjson_arr_size(avg);
    if (count == 0) return 0.0;
    yyjson_val *last = yyjson_arr_get(avg, count - 1);
    return (last && yyjson_is_num(last)) ? yyjson_get_num(last) : 0.0;
}
```

Implement `json_parse_pipeline_stats()`:
1. Parse JSON. Root must be an array (yyjson_is_arr).
2. First pass: count system entries (those with "name" field, NOT "system_count").
3. Allocate system_info_t array of that size.
4. Second pass: for each array element with a "name" field:
   - Extract `name` (dot-separated full path): `full_path = strdup(name_str)`
   - Extract leaf name: find last '.' in name_str, leaf = strdup(everything after last dot). If no dot, leaf = strdup(name_str).
   - Extract `disabled`: `yyjson_obj_get(entry, "disabled")` -- bool, default false
   - Extract `matched_entity_count`: `(int)extract_pipeline_gauge(entry, "matched_entity_count")` -- may not exist for task systems, default 0
   - Extract `matched_table_count`: `(int)extract_pipeline_gauge(entry, "matched_table_count")` -- same
   - Extract `time_spent_ms`: `extract_pipeline_gauge(entry, "time_spent") * 1000.0` -- seconds to ms
   - `phase` field: set to NULL here. Phase comes from entity tags and will be filled by tab_ecs.c enrichment logic in Plan 02.
5. Elements with "system_count" field (sync points): skip entirely.
6. Set reg->count, free doc, return reg.

IMPORTANT: The `phase` field is NOT set in the parser. Pipeline stats don't contain phase info. Phase comes from entity tags (already classified in tab_ecs.c's classify_node). The enrichment/merge happens in Plan 02.
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -5` shows no errors.
  </verify>
  <done>
system_info_t, system_registry_t defined in data_model.h with lifecycle functions in data_model.c. json_parse_pipeline_stats() parses /stats/pipeline response, extracting name, disabled, match counts, and timing per system. Sync points are skipped. Phase field left NULL for later enrichment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Phase color pairs + app_state + polling + ECS endpoint mask</name>
  <files>
    tools/cels-debug/src/tui.h
    tools/cels-debug/src/tui.c
    tools/cels-debug/src/main.c
    tools/cels-debug/src/tab_system.c
  </files>
  <action>
**tui.h** -- Add phase color pair defines after `CP_CURSOR 15`:
```c
/* Phase 04: system phase color pairs */
#define CP_PHASE_ONLOAD      16
#define CP_PHASE_POSTLOAD    17
#define CP_PHASE_PREUPDATE   18
#define CP_PHASE_ONUPDATE    19
#define CP_PHASE_ONVALIDATE  20
#define CP_PHASE_POSTUPDATE  21
#define CP_PHASE_PRESTORE    22
#define CP_PHASE_ONSTORE     23
#define CP_PHASE_POSTFRAME   24
#define CP_PHASE_CUSTOM      25
#define CP_SYSTEM_DISABLED   26
```

Add `system_registry_t *system_registry;` to `app_state_t` struct, with a comment `/* from /stats/pipeline */`. Place it after the `component_registry` field.

**tui.c** -- Add init_pair calls inside the `if (has_colors())` block, after existing color pairs:
```c
/* Phase 04: system phase color pairs */
init_pair(CP_PHASE_ONLOAD,     COLOR_BLUE,    -1);
init_pair(CP_PHASE_POSTLOAD,   COLOR_BLUE,    -1);
init_pair(CP_PHASE_PREUPDATE,  COLOR_CYAN,    -1);
init_pair(CP_PHASE_ONUPDATE,   COLOR_GREEN,   -1);
init_pair(CP_PHASE_ONVALIDATE, COLOR_YELLOW,  -1);
init_pair(CP_PHASE_POSTUPDATE, COLOR_YELLOW,  -1);
init_pair(CP_PHASE_PRESTORE,   COLOR_MAGENTA, -1);
init_pair(CP_PHASE_ONSTORE,    COLOR_RED,     -1);
init_pair(CP_PHASE_POSTFRAME,  COLOR_WHITE,   -1);
init_pair(CP_PHASE_CUSTOM,     COLOR_WHITE,   -1);
init_pair(CP_SYSTEM_DISABLED,  COLOR_WHITE,   -1);
```

**tab_system.c** -- Update ECS tab's required_endpoints to include ENDPOINT_STATS_PIPELINE:
Change line for ECS tab from:
`ENDPOINT_QUERY | ENDPOINT_ENTITY | ENDPOINT_COMPONENTS`
to:
`ENDPOINT_QUERY | ENDPOINT_ENTITY | ENDPOINT_COMPONENTS | ENDPOINT_STATS_PIPELINE`

**main.c** -- Add /stats/pipeline polling block. Add it after the component registry polling block (after `if ((needed & ENDPOINT_COMPONENTS) ...`), before the footer message expiry:

```c
/* Poll pipeline stats if active tab needs it */
if ((needed & ENDPOINT_STATS_PIPELINE) && app_state.conn_state == CONN_CONNECTED) {
    http_response_t presp = http_get(curl,
        "http://localhost:27750/stats/pipeline");
    if (presp.status == 200 && presp.body.data) {
        system_registry_t *new_reg =
            json_parse_pipeline_stats(presp.body.data, presp.body.size);
        if (new_reg) {
            system_registry_free(app_state.system_registry);
            app_state.system_registry = new_reg;
        }
    }
    http_response_free(&presp);
}
```

Add cleanup in the shutdown section (after `component_registry_free` call):
```c
system_registry_free(app_state.system_registry);
```

IMPORTANT: The `app_state` initializer `{0}` already zeroes system_registry to NULL, so no initialization change needed.
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -5`.
Run the debug tool (`./run.sh debug` or direct execution) with a CELS app running and verify no crash. Check that pipeline polling occurs by adding a temporary fprintf to the pipeline polling block, or verify the system_registry pointer is non-NULL after connecting (can be observed via breakpoint or temporary printf).
  </verify>
  <done>
Phase color pairs defined (CP_PHASE_ONLOAD through CP_SYSTEM_DISABLED) and initialized. system_registry_t* added to app_state_t. ECS tab requests ENDPOINT_STATS_PIPELINE. Main loop polls /stats/pipeline, parses response, stores in app_state.system_registry, and frees on exit. The data pipeline is complete -- system_registry_t is populated every 500ms when ECS tab is active.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --target cels_debug` compiles without errors or warnings
2. Run with a CELS app: app_state.system_registry is populated after first successful poll
3. system_registry_free in cleanup prevents memory leaks
4. No new runtime dependencies -- all existing endpoints continue to work
</verification>

<success_criteria>
- data_model.h defines system_info_t and system_registry_t with all fields from research
- json_parse_pipeline_stats correctly differentiates system entries (has "name") from sync points (has "system_count")
- Gauge values extracted using last element of "avg" array (same pattern as extract_latest_gauge)
- Phase color pairs available (CP_PHASE_ONLOAD..CP_SYSTEM_DISABLED = 16..26)
- ECS tab endpoint mask includes ENDPOINT_STATS_PIPELINE
- Main loop polls /stats/pipeline and stores result in app_state.system_registry
- Build succeeds with zero new warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-systems-and-pipeline/04-01-SUMMARY.md`
</output>
