---
phase: 04-systems-and-pipeline
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - tools/cels-debug/src/tabs/tab_ecs.c
autonomous: true

must_haves:
  truths:
    - "Selecting a system in the tree shows full metadata in the inspector (phase, enabled, match count, timing, component access)"
    - "Inspector shows entities with overlapping components as approximate matches (based on component access pattern, not exact system query)"
    - "Pressing Enter on an approximate match in the inspector cross-navigates to that entity in the Entities section"
    - "Cross-navigation uncollapses the Entities section if needed and moves the tree cursor"
    - "Cross-navigation shows footer message if target entity not found"
  artifacts:
    - path: "tools/cels-debug/src/tabs/tab_ecs.c"
      provides: "System detail inspector + cross-navigation"
      contains: "cross_navigate"
  key_links:
    - from: "tabs/tab_ecs.c system inspector"
      to: "tabs/tab_ecs.c entity tree"
      via: "cross_navigate_to_entity sets cursor and uncollapse"
      pattern: "cross_navigate_to_entity"
    - from: "tabs/tab_ecs.c system inspector"
      to: "system_registry_t"
      via: "lookup system metadata by name"
      pattern: "system_registry.*name"
---

<objective>
Add the system detail inspector panel (metadata + approximate matched entity list) and cross-navigation from matched entities to the Entities section of the CELS-C tree.

Purpose: Completes the system inspection workflow. Users select a system, see its full metadata, browse approximate matched entities (based on component overlap), and can jump to any matched entity in the entity tree.
Output: Full system detail inspector with cross-navigation, completing Phase 04 feature set.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/STATE.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-RESEARCH.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-CONTEXT.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-03-SUMMARY.md

@tools/cels-debug/src/tabs/tab_ecs.c
@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/tree_view.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: System detail inspector rendering</name>
  <files>
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
Add a new inspector branch for when a system entity is selected. This goes in `tab_ecs_draw()` in the inspector dispatch logic. Insert AFTER the phase/summary header check and BEFORE the existing component entity check:

```c
} else if (sel && sel->entity_class == ENTITY_CLASS_SYSTEM) {
    /* --- Branch: System entity selected -> System detail + matched entities --- */
    draw_system_detail(rwin, rh, rw, sel, state, es);
} else if (sel && sel->entity_class == ENTITY_CLASS_COMPONENT) {
    /* ... existing component inspector ... */
```

Implement `find_system_info()` helper:
```c
static system_info_t *find_system_info(const app_state_t *state,
                                        const char *name) {
    if (!state->system_registry || !name) return NULL;
    for (int i = 0; i < state->system_registry->count; i++) {
        if (state->system_registry->systems[i].name &&
            strcmp(state->system_registry->systems[i].name, name) == 0) {
            return &state->system_registry->systems[i];
        }
    }
    return NULL;
}
```

Implement `build_system_matches()` -- finds entities with overlapping components (approximation, not exact query match):
```c
/* Find entities that share components with this system's access pattern.
 * This is an APPROXIMATION -- the Flecs REST API does not expose the exact
 * query expression, so we match entities that have at least one non-flecs
 * component from the system's component list. Not all returned entities
 * are necessarily matched by the system's actual query.
 * Returns array of entity_node_t pointers. Caller frees the array (not nodes). */
static entity_node_t **build_system_matches(const entity_detail_t *sys_detail,
                                             const entity_list_t *elist,
                                             int *out_count) {
    *out_count = 0;
    if (!sys_detail || !elist || !sys_detail->components) return NULL;

    /* Collect system's non-internal component names */
    int comp_count = 0;
    const char *comp_names[64];
    if (yyjson_is_obj(sys_detail->components)) {
        size_t ci, cmax;
        yyjson_val *ckey, *cval;
        yyjson_obj_foreach(sys_detail->components, ci, cmax, ckey, cval) {
            if (comp_count < 64) {
                comp_names[comp_count++] = yyjson_get_str(ckey);
            }
        }
    }
    if (comp_count == 0) return NULL;

    /* Filter out system-internal components */
    const char *query_comps[64];
    int query_count = 0;
    for (int i = 0; i < comp_count; i++) {
        if (!comp_names[i]) continue;
        if (strncmp(comp_names[i], "flecs.", 6) == 0) continue;
        if (strcmp(comp_names[i], "Component") == 0) continue;
        query_comps[query_count++] = comp_names[i];
    }
    if (query_count == 0) return NULL;

    /* Find entities with at least one overlapping component */
    entity_node_t **matches = malloc((size_t)elist->count * sizeof(entity_node_t *));
    if (!matches) return NULL;
    int match_count = 0;

    for (int i = 0; i < elist->count; i++) {
        entity_node_t *node = elist->nodes[i];
        if (node->entity_class == ENTITY_CLASS_SYSTEM) continue;
        if (node->entity_class == ENTITY_CLASS_COMPONENT) continue;

        bool has_match = false;
        for (int q = 0; q < query_count && !has_match; q++) {
            for (int c = 0; c < node->component_count; c++) {
                if (node->component_names[c] &&
                    strcmp(node->component_names[c], query_comps[q]) == 0) {
                    has_match = true;
                    break;
                }
            }
        }
        if (has_match) {
            matches[match_count++] = node;
        }
    }

    *out_count = match_count;
    return matches;
}
```

Implement `draw_system_detail()`:
```c
static void draw_system_detail(WINDOW *rwin, int rh, int rw,
                                entity_node_t *sel,
                                const app_state_t *state,
                                ecs_state_t *es) {
    int row = 1;

    /* Title: system name */
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, row, 1, "%.*s", rw, sel->name ? sel->name : "(unnamed)");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    row++;

    /* Separator */
    wattron(rwin, A_DIM);
    wmove(rwin, row, 1);
    for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
    wattroff(rwin, A_DIM);
    row++;

    /* Metadata */
    system_info_t *sinfo = find_system_info(state, sel->name);

    /* Phase */
    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 2, "Phase");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    if (sel->class_detail) {
        int cp = phase_color_pair(sel->class_detail);
        wattron(rwin, COLOR_PAIR(cp) | A_BOLD);
        mvwprintw(rwin, row, 16, "%s", sel->class_detail);
        wattroff(rwin, COLOR_PAIR(cp) | A_BOLD);
    } else {
        wattron(rwin, A_DIM);
        mvwprintw(rwin, row, 16, "Unknown");
        wattroff(rwin, A_DIM);
    }

    /* Status */
    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 2, "Status");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    if (sel->disabled) {
        wattron(rwin, COLOR_PAIR(CP_DISCONNECTED));
        mvwprintw(rwin, row, 16, "Disabled");
        wattroff(rwin, COLOR_PAIR(CP_DISCONNECTED));
    } else {
        wattron(rwin, COLOR_PAIR(CP_CONNECTED));
        mvwprintw(rwin, row, 16, "Enabled");
        wattroff(rwin, COLOR_PAIR(CP_CONNECTED));
    }

    /* Match count */
    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 2, "Matched");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    mvwprintw(rwin, row, 16, "%d entities", sel->system_match_count);
    wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));

    /* Timing */
    if (sinfo && sinfo->time_spent_ms > 0.0) {
        row++;
        wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
        mvwprintw(rwin, row, 2, "Time");
        wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
        wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
        mvwprintw(rwin, row, 16, "%.2fms", sinfo->time_spent_ms);
        wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    }

    /* Table count */
    if (sinfo && sinfo->matched_table_count > 0) {
        row++;
        wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
        mvwprintw(rwin, row, 2, "Tables");
        wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
        wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
        mvwprintw(rwin, row, 16, "%d", sinfo->matched_table_count);
        wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    }

    /* Full path */
    if (sinfo && sinfo->full_path) {
        row++;
        wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
        mvwprintw(rwin, row, 2, "Path");
        wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
        wattron(rwin, A_DIM);
        mvwprintw(rwin, row, 16, "%.*s", rw - 16, sinfo->full_path);
        wattroff(rwin, A_DIM);
    }

    /* Component access list from entity detail */
    if (state->entity_detail && sel->full_path &&
        strcmp(state->entity_detail->path, sel->full_path) == 0) {
        if (state->entity_detail->components &&
            yyjson_is_obj(state->entity_detail->components)) {
            row += 2;
            wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
            mvwprintw(rwin, row, 1, "Component Access");
            wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
            row++;

            size_t ci, cmax;
            yyjson_val *ckey, *cval;
            yyjson_obj_foreach(state->entity_detail->components, ci, cmax, ckey, cval) {
                if (row >= rh) break;
                wattron(rwin, COLOR_PAIR(CP_JSON_STRING));
                mvwprintw(rwin, row, 3, "%.*s", rw - 4, yyjson_get_str(ckey));
                wattroff(rwin, COLOR_PAIR(CP_JSON_STRING));
                row++;
            }
        }
    }

    /* Approximate matched entities section (scrollable) */
    row += 1;
    int match_header_row = row;
    if (match_header_row < rh) {
        wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
        mvwprintw(rwin, match_header_row, 1, "Matched Entities");
        wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);

        /* Note: this is a component overlap approximation */
        wattron(rwin, A_DIM);
        mvwprintw(rwin, match_header_row, 19, "(approx)");
        wattroff(rwin, A_DIM);

        /* Build approximate match list from entity detail component access */
        int match_count = 0;
        entity_node_t **matches = NULL;
        if (state->entity_detail && sel->full_path &&
            strcmp(state->entity_detail->path, sel->full_path) == 0) {
            matches = build_system_matches(state->entity_detail,
                                            state->entity_list, &match_count);
        }

        int avail_rows = rh - (match_header_row + 1);
        if (avail_rows < 1) avail_rows = 1;

        es->inspector_scroll.total_items = match_count;
        es->inspector_scroll.visible_rows = avail_rows;
        scroll_ensure_visible(&es->inspector_scroll);

        if (match_count > 0 && matches) {
            for (int r = 0; r < avail_rows; r++) {
                int idx = es->inspector_scroll.scroll_offset + r;
                if (idx >= match_count) break;

                int disp_row = match_header_row + 1 + r;
                entity_node_t *ent = matches[idx];
                bool is_cursor = (idx == es->inspector_scroll.cursor &&
                                  es->panel.focus == 1);

                if (is_cursor) wattron(rwin, A_REVERSE);

                wmove(rwin, disp_row, 1);
                for (int c = 0; c < rw; c++) waddch(rwin, ' ');

                const char *dname = ent->name;
                char id_buf[32];
                if (!dname || dname[0] == '\0') {
                    snprintf(id_buf, sizeof(id_buf), "#%lu",
                             (unsigned long)ent->id);
                    dname = id_buf;
                }

                wattron(rwin, COLOR_PAIR(CP_ENTITY_NAME));
                mvwprintw(rwin, disp_row, 2, "%.*s", rw / 2, dname);
                wattroff(rwin, COLOR_PAIR(CP_ENTITY_NAME));

                if (ent->full_path) {
                    int name_end = getcurx(rwin);
                    int avail = rw - (name_end - 1);
                    if (avail > 2) {
                        wattron(rwin, A_DIM);
                        mvwprintw(rwin, disp_row, name_end + 1, "%.*s",
                                  avail - 2, ent->full_path);
                        wattroff(rwin, A_DIM);
                    }
                }

                if (is_cursor) wattroff(rwin, A_REVERSE);
            }
        } else {
            int disp_row = match_header_row + 1;
            if (disp_row < rh) {
                wattron(rwin, A_DIM);
                if (!state->entity_detail || !sel->full_path ||
                    strcmp(state->entity_detail->path, sel->full_path) != 0) {
                    mvwprintw(rwin, disp_row, 3, "Loading...");
                } else {
                    mvwprintw(rwin, disp_row, 3, "No matches (task system)");
                }
                wattroff(rwin, A_DIM);
            }
        }

        free(matches);
    }
}
```

The entity detail for a system entity is already fetched by the existing entity detail polling mechanism (selected_entity_path triggers /entity/<path> poll). The component access list and matched entity list appear when entity_detail loads (takes one poll cycle).
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with CELS app. Navigate to ECS tab, expand Systems, select a system entity:
1. Inspector shows system name as title
2. Phase shown in phase color
3. Status shows Enabled (green) or Disabled (red)
4. Match count displayed
5. Timing displayed if available
6. Component access list appears after entity detail loads
7. Matched Entities section shows "(approx)" label
  </verify>
  <done>
System detail inspector renders when a system entity is selected. Shows phase (color-coded), status, match count, timing, table count, full path, component access list, and approximate matched entity list. Matched entities built by finding entities with overlapping components (approximation clearly labeled). Scrollable entity list in inspector.
  </done>
</task>

<task type="auto">
  <name>Task 2: Cross-navigation from system inspector to entity tree</name>
  <files>
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
Implement `cross_navigate_to_entity()`:
```c
static bool cross_navigate_to_entity(ecs_state_t *es, app_state_t *state,
                                      const char *entity_path) {
    if (!entity_path || !state->entity_list) return false;

    /* 1. Ensure Entities section is expanded */
    es->tree.section_collapsed[ENTITY_CLASS_ENTITY] = false;

    /* 2. Rebuild visible rows to include Entities section items */
    tree_view_rebuild_visible(&es->tree, state->entity_list);

    /* 3. Find the target entity in the display list */
    for (int i = 0; i < es->tree.row_count; i++) {
        entity_node_t *node = es->tree.rows[i].node;
        if (node && node->full_path &&
            strcmp(node->full_path, entity_path) == 0) {
            es->tree.scroll.cursor = i;
            scroll_ensure_visible(&es->tree.scroll);

            /* 4. Update selected path for detail polling */
            free(state->selected_entity_path);
            state->selected_entity_path = strdup(entity_path);

            /* 5. Switch focus to left panel */
            es->panel.focus = 0;
            return true;
        }
    }

    /* Try expanding Compositions section too */
    es->tree.section_collapsed[ENTITY_CLASS_COMPOSITION] = false;
    tree_view_rebuild_visible(&es->tree, state->entity_list);

    for (int i = 0; i < es->tree.row_count; i++) {
        entity_node_t *node = es->tree.rows[i].node;
        if (node && node->full_path &&
            strcmp(node->full_path, entity_path) == 0) {
            es->tree.scroll.cursor = i;
            scroll_ensure_visible(&es->tree.scroll);
            free(state->selected_entity_path);
            state->selected_entity_path = strdup(entity_path);
            es->panel.focus = 0;
            return true;
        }
    }

    /* Not found -- show footer message */
    free(state->footer_message);
    state->footer_message = strdup("Entity not found");
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    state->footer_message_expire = ts.tv_sec * 1000 + ts.tv_nsec / 1000000 + 3000;
    return false;
}
```

Add `#include <time.h>` at the top of tab_ecs.c if not already present (for clock_gettime). Ensure `_POSIX_C_SOURCE 200809L` is defined (already present).

Wire cross-navigation into input handling. In `tab_ecs_input()`, in the right panel focus section, add a branch for system entities BEFORE the existing component check:

```c
if (es->panel.focus == 1) {
    entity_node_t *sel = tree_view_selected(&es->tree);

    if (sel && sel->entity_class == ENTITY_CLASS_SYSTEM) {
        /* System detail mode: scroll matched entities + cross-navigate */
        switch (ch) {
        case KEY_UP:
        case 'k':
            scroll_move(&es->inspector_scroll, -1);
            return true;
        case KEY_DOWN:
        case 'j':
            scroll_move(&es->inspector_scroll, +1);
            return true;
        case KEY_PPAGE:
            scroll_page(&es->inspector_scroll, -1);
            return true;
        case KEY_NPAGE:
            scroll_page(&es->inspector_scroll, +1);
            return true;
        case 'g':
            scroll_to_top(&es->inspector_scroll);
            return true;
        case 'G':
            scroll_to_bottom(&es->inspector_scroll);
            return true;
        case KEY_ENTER:
        case '\n':
        case '\r': {
            /* Cross-navigate to approximate matched entity */
            int match_count = 0;
            entity_node_t **matches = NULL;
            if (state->entity_detail && sel->full_path &&
                strcmp(state->entity_detail->path, sel->full_path) == 0) {
                matches = build_system_matches(state->entity_detail,
                                                state->entity_list, &match_count);
            }
            if (matches && es->inspector_scroll.cursor >= 0 &&
                es->inspector_scroll.cursor < match_count) {
                entity_node_t *target = matches[es->inspector_scroll.cursor];
                if (target->full_path) {
                    cross_navigate_to_entity(es, state, target->full_path);
                }
            }
            free(matches);
            return true;
        }
        }
    } else if (sel && sel->entity_class == ENTITY_CLASS_COMPONENT) {
        /* ... existing component mode input handling ... */
    } else {
        /* ... existing entity detail mode input handling ... */
    }
}
```
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with CELS app. Test the full workflow:
1. Navigate to ECS tab, expand Systems section
2. Select a system entity -> inspector shows metadata
3. After entity detail loads, approximate matched entities appear below component access list
4. Switch focus to right panel (right arrow), scroll through matched entities with j/k
5. Press Enter on a matched entity -> cursor jumps to that entity in the Entities section (left panel)
6. Entities section is auto-expanded if it was collapsed
7. If target entity not found, footer shows "Entity not found" for 3 seconds
  </verify>
  <done>
Cross-navigation implemented via cross_navigate_to_entity(). Uncollapses Entities section (and Compositions if needed), moves cursor, updates selected_entity_path, switches focus to left panel. Footer notification on entity-not-found. Input handling for system inspector: j/k scroll matched entity list, Enter cross-navigates to selected match. Matches array freed after each use (no leaks).
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero warnings
2. System detail inspector renders correctly for all system types (with/without query, with/without timing)
3. Matched entity list is populated and scrollable, labeled "(approx)"
4. Cross-navigation jumps to correct entity in tree
5. Cross-navigation uncollapses target section
6. Entity-not-found shows footer message
7. No memory leaks (matches array freed after each use)
</verification>

<success_criteria>
- System entity selection shows full metadata inspector (phase, status, match count, timing, component access)
- Approximate matched entities listed based on component overlap (clearly labeled as approximation)
- Enter on matched entity cross-navigates to Entities section
- Cross-navigation uncollapses Entities (and Compositions) sections if needed
- Footer message "Entity not found" shown when target is missing
- Right panel scroll works for matched entity list (j/k, PgUp/PgDn)
- All system types handled: systems with queries (show approx matches), task systems (show "No matches")
</success_criteria>

<output>
After completion, create `.planning/phases/04-systems-and-pipeline/04-04-SUMMARY.md`
</output>
