---
phase: 04-systems-and-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - tools/cels-debug/src/tabs/tab_ecs.c
autonomous: true

must_haves:
  truths:
    - "Selecting a system in the tree shows full metadata in the inspector (phase, enabled, match count, timing, component access)"
    - "Inspector shows a scrollable list of matched entities for the selected system"
    - "Pressing Enter on a matched entity in the inspector cross-navigates to that entity in the Entities section"
    - "Cross-navigation uncollapse the Entities section if needed and moves the tree cursor"
    - "Cross-navigation shows footer message if target entity not found"
  artifacts:
    - path: "tools/cels-debug/src/tabs/tab_ecs.c"
      provides: "System detail inspector + cross-navigation"
      contains: "cross_navigate"
  key_links:
    - from: "tabs/tab_ecs.c system inspector"
      to: "tabs/tab_ecs.c entity tree"
      via: "cross_navigate_to_entity sets cursor and uncollapse"
      pattern: "cross_navigate_to_entity"
    - from: "tabs/tab_ecs.c system inspector"
      to: "system_registry_t"
      via: "lookup system metadata by name"
      pattern: "system_registry.*name"
---

<objective>
Add the system detail inspector panel (metadata + matched entity list) and cross-navigation from matched entities to the Entities section of the CELS-C tree.

Purpose: Completes the system inspection workflow. Users select a system, see its full metadata, browse matched entities, and can jump to any matched entity in the entity tree.
Output: Full system detail inspector with cross-navigation, completing Phase 04 feature set.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/STATE.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-RESEARCH.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-CONTEXT.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-02-SUMMARY.md

@tools/cels-debug/src/tabs/tab_ecs.c
@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/tree_view.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: System detail inspector rendering</name>
  <files>
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
Add a new inspector branch for when a system entity is selected. This goes in `tab_ecs_draw()` in the inspector dispatch logic. Insert AFTER the phase/summary header check and BEFORE the existing component entity check:

```c
} else if (sel && sel->entity_class == ENTITY_CLASS_SYSTEM) {
    /* --- Branch: System entity selected -> System detail + matched entities --- */
    draw_system_detail(rwin, rh, rw, sel, state, es);
} else if (sel && sel->entity_class == ENTITY_CLASS_COMPONENT) {
    /* ... existing component inspector ... */
```

Implement `draw_system_detail()`:

```c
/* Find system_info_t matching this entity node (by leaf name) */
static system_info_t *find_system_info(const app_state_t *state,
                                        const char *name) {
    if (!state->system_registry || !name) return NULL;
    for (int i = 0; i < state->system_registry->count; i++) {
        if (state->system_registry->systems[i].name &&
            strcmp(state->system_registry->systems[i].name, name) == 0) {
            return &state->system_registry->systems[i];
        }
    }
    return NULL;
}

static void draw_system_detail(WINDOW *rwin, int rh, int rw,
                                entity_node_t *sel,
                                const app_state_t *state,
                                ecs_state_t *es) {
    int row = 1;

    /* Title: system name */
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, row, 1, "%.*s", rw, sel->name ? sel->name : "(unnamed)");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    row++;

    /* Separator */
    wattron(rwin, A_DIM);
    wmove(rwin, row, 1);
    for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
    wattroff(rwin, A_DIM);
    row++;

    /* Metadata section */
    system_info_t *sinfo = find_system_info(state, sel->name);

    /* Phase */
    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 2, "Phase");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    if (sel->class_detail) {
        int cp = phase_color_pair(sel->class_detail);
        wattron(rwin, COLOR_PAIR(cp) | A_BOLD);
        mvwprintw(rwin, row, 16, "%s", sel->class_detail);
        wattroff(rwin, COLOR_PAIR(cp) | A_BOLD);
    } else {
        wattron(rwin, A_DIM);
        mvwprintw(rwin, row, 16, "Unknown");
        wattroff(rwin, A_DIM);
    }

    /* Status */
    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 2, "Status");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    if (sel->disabled) {
        wattron(rwin, COLOR_PAIR(CP_DISCONNECTED));
        mvwprintw(rwin, row, 16, "Disabled");
        wattroff(rwin, COLOR_PAIR(CP_DISCONNECTED));
    } else {
        wattron(rwin, COLOR_PAIR(CP_CONNECTED));
        mvwprintw(rwin, row, 16, "Enabled");
        wattroff(rwin, COLOR_PAIR(CP_CONNECTED));
    }

    /* Match count */
    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 2, "Matched");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    mvwprintw(rwin, row, 16, "%d entities", sel->system_match_count);
    wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));

    /* Timing */
    if (sinfo && sinfo->time_spent_ms > 0.0) {
        row++;
        wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
        mvwprintw(rwin, row, 2, "Time");
        wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
        wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
        mvwprintw(rwin, row, 16, "%.2fms", sinfo->time_spent_ms);
        wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    }

    /* Table count */
    if (sinfo && sinfo->matched_table_count > 0) {
        row++;
        wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
        mvwprintw(rwin, row, 2, "Tables");
        wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
        wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
        mvwprintw(rwin, row, 16, "%d", sinfo->matched_table_count);
        wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    }

    /* Full path */
    if (sinfo && sinfo->full_path) {
        row++;
        wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
        mvwprintw(rwin, row, 2, "Path");
        wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
        wattron(rwin, A_DIM);
        mvwprintw(rwin, row, 16, "%.*s", rw - 16, sinfo->full_path);
        wattroff(rwin, A_DIM);
    }

    /* Component access list from entity detail (tags, components) */
    if (state->entity_detail && sel->full_path &&
        strcmp(state->entity_detail->path, sel->full_path) == 0) {
        /* Show component access from entity detail */
        if (state->entity_detail->components &&
            yyjson_is_obj(state->entity_detail->components)) {
            row += 2;
            wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
            mvwprintw(rwin, row, 1, "Component Access");
            wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
            row++;

            size_t ci, cmax;
            yyjson_val *ckey, *cval;
            yyjson_obj_foreach(state->entity_detail->components, ci, cmax, ckey, cval) {
                if (row >= rh) break;
                wattron(rwin, COLOR_PAIR(CP_JSON_STRING));
                mvwprintw(rwin, row, 3, "%.*s", rw - 4, yyjson_get_str(ckey));
                wattroff(rwin, COLOR_PAIR(CP_JSON_STRING));
                row++;
            }
        }
    }

    /* Matched entities section (scrollable) */
    row += 1;
    if (row < rh) {
        wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
        mvwprintw(rwin, row, 1, "Matched Entities");
        wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
        row++;

        /* Build matched entity list by finding entities that have components
         * this system queries. For now, since we don't have the query expression
         * from the REST API, show a hint about match count instead.
         *
         * FUTURE: When /entity/<system_path> returns query expression,
         * parse it to identify matched entities.
         *
         * For NOW: Display the match count and a note. The entity detail
         * endpoint for a system doesn't return its matched entities directly.
         * Cross-navigation will be available once entity detail for systems
         * includes query data. */
        if (sel->system_match_count > 0) {
            wattron(rwin, A_DIM);
            mvwprintw(rwin, row, 3, "%d entities matched", sel->system_match_count);
            row++;
            mvwprintw(rwin, row, 3, "(query details in entity detail)");
            wattroff(rwin, A_DIM);
        } else {
            wattron(rwin, A_DIM);
            mvwprintw(rwin, row, 3, "No matches (task system)");
            wattroff(rwin, A_DIM);
        }
    }
}
```

IMPORTANT: The entity detail for a system entity IS already fetched by the existing entity detail polling mechanism (when the system is selected, selected_entity_path is set, and /entity/<path> is polled). This gives us the system's components (which represent the system's query/filter access pattern). The component access list above uses this data.

The system detail inspector renders the system's metadata immediately (from enriched entity_node_t fields and system_registry lookup). The component access list appears when entity_detail loads (takes one poll cycle).
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with CELS app. Navigate to ECS tab, expand Systems, select a system entity:
1. Inspector shows system name as title
2. Phase shown in phase color
3. Status shows Enabled (green) or Disabled (red)
4. Match count displayed
5. Timing displayed if available
6. Component access list appears after entity detail loads
  </verify>
  <done>
System detail inspector renders when a system entity is selected in the tree. Shows phase (color-coded), status, match count, timing, table count, full path, and component access list from entity detail.
  </done>
</task>

<task type="auto">
  <name>Task 2: Cross-navigation from system inspector to entity tree</name>
  <files>
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
Cross-navigation allows jumping from the system inspector to an entity in the Entities section. Since we cannot directly list a system's matched entities from the REST API (the pipeline stats only give counts, not entity lists), cross-navigation applies when:
1. The inspector shows an entity list (like the component browser's entity list)
2. The user is in the right panel focused on a matched entity

For Phase 04, the most useful cross-navigation is from the **component browser** when a user is inspecting a system's component access -- if they select a component from the access list, they could navigate to it in the Components section. However, the CONTEXT.md specifically mentions "Enter on a matched entity cross-navigates to that entity in the Entities section."

Since we can't get matched entities directly, implement cross-navigation as a generic utility that CAN be triggered whenever an entity path is known. For now, wire it up to:

1. **System selection + right panel**: When viewing a system and pressing Enter in the right panel on a component access entry, navigate to that component in the Components section.

Actually, re-reading CONTEXT.md: "Matched entity interaction: Enter on a matched entity cross-navigates to that entity in the Entities section of the CELS-C tree." This implies a scrollable list of matched entities in the inspector. Since the Flecs REST API doesn't provide this list directly (only counts), we need to implement it differently:

APPROACH: The system entity detail from /entity/<system_path> includes a "query" component that describes what the system queries. We can filter the entity_list to find entities that match (have the components the system queries). This gives us the matched entity list.

For a simpler first pass: use the system's component access list (from entity detail) to filter entities that have ALL of those components. This is an approximation of the system's query matches.

Implement `build_system_matches()`:
```c
/* Find entities that have all the components this system accesses.
 * Returns array of entity_node_t pointers. Caller must free the array (not nodes). */
static entity_node_t **build_system_matches(const entity_detail_t *sys_detail,
                                             const entity_list_t *elist,
                                             int *out_count) {
    *out_count = 0;
    if (!sys_detail || !elist || !sys_detail->components) return NULL;

    /* Collect system's component names */
    int comp_count = 0;
    const char *comp_names[64];
    if (yyjson_is_obj(sys_detail->components)) {
        size_t ci, cmax;
        yyjson_val *ckey, *cval;
        yyjson_obj_foreach(sys_detail->components, ci, cmax, ckey, cval) {
            if (comp_count < 64) {
                comp_names[comp_count++] = yyjson_get_str(ckey);
            }
        }
    }
    if (comp_count == 0) return NULL;

    /* Filter: skip components that are system-internal (flecs.system.*, flecs.core.*) */
    const char *query_comps[64];
    int query_count = 0;
    for (int i = 0; i < comp_count; i++) {
        if (!comp_names[i]) continue;
        if (strncmp(comp_names[i], "flecs.", 6) == 0) continue;
        if (strcmp(comp_names[i], "Component") == 0) continue;
        query_comps[query_count++] = comp_names[i];
    }
    if (query_count == 0) return NULL;

    /* Find entities with at least one query component */
    entity_node_t **matches = malloc((size_t)elist->count * sizeof(entity_node_t *));
    if (!matches) return NULL;
    int match_count = 0;

    for (int i = 0; i < elist->count; i++) {
        entity_node_t *node = elist->nodes[i];
        if (node->entity_class == ENTITY_CLASS_SYSTEM) continue; /* skip systems */
        if (node->entity_class == ENTITY_CLASS_COMPONENT) continue; /* skip component types */

        /* Check if entity has any of the query components */
        bool has_match = false;
        for (int q = 0; q < query_count && !has_match; q++) {
            for (int c = 0; c < node->component_count; c++) {
                if (node->component_names[c] &&
                    strcmp(node->component_names[c], query_comps[q]) == 0) {
                    has_match = true;
                    break;
                }
            }
        }
        if (has_match) {
            matches[match_count++] = node;
        }
    }

    *out_count = match_count;
    return matches;
}
```

Update `draw_system_detail()` to replace the "Matched Entities" placeholder section with an actual scrollable entity list. Use `es->inspector_scroll` for scrolling:

Replace the "Matched Entities" section at the bottom of draw_system_detail with:

```c
    /* Matched entities (scrollable list) */
    int match_header_row = row + 1;
    if (match_header_row < rh) {
        wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
        mvwprintw(rwin, match_header_row, 1, "Matched Entities");
        wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);

        /* Build match list from entity detail */
        int match_count = 0;
        entity_node_t **matches = NULL;
        if (state->entity_detail && sel->full_path &&
            strcmp(state->entity_detail->path, sel->full_path) == 0) {
            matches = build_system_matches(state->entity_detail,
                                            state->entity_list, &match_count);
        }

        int avail_rows = rh - (match_header_row + 1);
        if (avail_rows < 1) avail_rows = 1;

        es->inspector_scroll.total_items = match_count;
        es->inspector_scroll.visible_rows = avail_rows;
        scroll_ensure_visible(&es->inspector_scroll);

        if (match_count > 0 && matches) {
            for (int r = 0; r < avail_rows; r++) {
                int idx = es->inspector_scroll.scroll_offset + r;
                if (idx >= match_count) break;

                int disp_row = match_header_row + 1 + r;
                entity_node_t *ent = matches[idx];
                bool is_cursor = (idx == es->inspector_scroll.cursor &&
                                  es->panel.focus == 1);

                if (is_cursor) wattron(rwin, A_REVERSE);

                /* Clear row */
                wmove(rwin, disp_row, 1);
                for (int c = 0; c < rw; c++) waddch(rwin, ' ');

                const char *dname = ent->name;
                char id_buf[32];
                if (!dname || dname[0] == '\0') {
                    snprintf(id_buf, sizeof(id_buf), "#%lu",
                             (unsigned long)ent->id);
                    dname = id_buf;
                }

                wattron(rwin, COLOR_PAIR(CP_ENTITY_NAME));
                mvwprintw(rwin, disp_row, 2, "%.*s", rw / 2, dname);
                wattroff(rwin, COLOR_PAIR(CP_ENTITY_NAME));

                if (ent->full_path) {
                    int name_end = getcurx(rwin);
                    int avail = rw - (name_end - 1);
                    if (avail > 2) {
                        wattron(rwin, A_DIM);
                        mvwprintw(rwin, disp_row, name_end + 1, "%.*s",
                                  avail - 2, ent->full_path);
                        wattroff(rwin, A_DIM);
                    }
                }

                if (is_cursor) wattroff(rwin, A_REVERSE);
            }
        } else {
            int disp_row = match_header_row + 1;
            if (disp_row < rh) {
                wattron(rwin, A_DIM);
                if (!state->entity_detail || !sel->full_path ||
                    strcmp(state->entity_detail->path, sel->full_path) != 0) {
                    mvwprintw(rwin, disp_row, 3, "Loading...");
                } else {
                    mvwprintw(rwin, disp_row, 3, "No matches (task system)");
                }
                wattroff(rwin, A_DIM);
            }
        }

        free(matches);
    }
```

NOTE: The `matches` array is rebuilt every draw call (same pattern as component browser). This is fine for the expected entity counts.

Implement `cross_navigate_to_entity()`:
```c
static bool cross_navigate_to_entity(ecs_state_t *es, app_state_t *state,
                                      const char *entity_path) {
    if (!entity_path || !state->entity_list) return false;

    /* 1. Ensure Entities section is expanded */
    es->tree.section_collapsed[ENTITY_CLASS_ENTITY] = false;

    /* 2. Rebuild visible rows to include Entities section items */
    tree_view_rebuild_visible(&es->tree, state->entity_list);

    /* 3. Find the target entity in the display list */
    for (int i = 0; i < es->tree.row_count; i++) {
        entity_node_t *node = es->tree.rows[i].node;
        if (node && node->full_path &&
            strcmp(node->full_path, entity_path) == 0) {
            es->tree.scroll.cursor = i;
            scroll_ensure_visible(&es->tree.scroll);

            /* 4. Update selected path for detail polling */
            free(state->selected_entity_path);
            state->selected_entity_path = strdup(entity_path);

            /* 5. Switch focus to left panel */
            es->panel.focus = 0;
            return true;
        }
    }

    /* Entity not found in current list -- check if it might be in a
     * collapsed parent. Try expanding Compositions section too. */
    es->tree.section_collapsed[ENTITY_CLASS_COMPOSITION] = false;
    tree_view_rebuild_visible(&es->tree, state->entity_list);

    for (int i = 0; i < es->tree.row_count; i++) {
        entity_node_t *node = es->tree.rows[i].node;
        if (node && node->full_path &&
            strcmp(node->full_path, entity_path) == 0) {
            es->tree.scroll.cursor = i;
            scroll_ensure_visible(&es->tree.scroll);
            free(state->selected_entity_path);
            state->selected_entity_path = strdup(entity_path);
            es->panel.focus = 0;
            return true;
        }
    }

    /* Not found */
    free(state->footer_message);
    state->footer_message = strdup("Entity not found");
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    state->footer_message_expire = ts.tv_sec * 1000 + ts.tv_nsec / 1000000 + 3000;
    return false;
}
```

NOTE: Add `#include <time.h>` at the top of tab_ecs.c if not already present (for clock_gettime).

Wire cross-navigation into input handling. In `tab_ecs_input()`, in the right panel focus section, add a branch for system entities:

```c
if (es->panel.focus == 1) {
    entity_node_t *sel = tree_view_selected(&es->tree);

    if (sel && sel->entity_class == ENTITY_CLASS_SYSTEM) {
        /* System detail mode: scroll matched entities + cross-navigate */
        switch (ch) {
        case KEY_UP:
        case 'k':
            scroll_move(&es->inspector_scroll, -1);
            return true;
        case KEY_DOWN:
        case 'j':
            scroll_move(&es->inspector_scroll, +1);
            return true;
        case KEY_PPAGE:
            scroll_page(&es->inspector_scroll, -1);
            return true;
        case KEY_NPAGE:
            scroll_page(&es->inspector_scroll, +1);
            return true;
        case 'g':
            scroll_to_top(&es->inspector_scroll);
            return true;
        case 'G':
            scroll_to_bottom(&es->inspector_scroll);
            return true;
        case KEY_ENTER:
        case '\n':
        case '\r': {
            /* Cross-navigate to matched entity */
            int match_count = 0;
            entity_node_t **matches = NULL;
            if (state->entity_detail && sel->full_path &&
                strcmp(state->entity_detail->path, sel->full_path) == 0) {
                matches = build_system_matches(state->entity_detail,
                                                state->entity_list, &match_count);
            }
            if (matches && es->inspector_scroll.cursor >= 0 &&
                es->inspector_scroll.cursor < match_count) {
                entity_node_t *target = matches[es->inspector_scroll.cursor];
                if (target->full_path) {
                    cross_navigate_to_entity(es, state, target->full_path);
                }
            }
            free(matches);
            return true;
        }
        }
    } else if (sel && sel->entity_class == ENTITY_CLASS_COMPONENT) {
        /* ... existing component mode input handling ... */
    } else {
        /* ... existing entity detail mode input handling ... */
    }
}
```

This inserts the system detail input handling BEFORE the existing component check in the right panel input section. The ordering matters: system check first, then component, then general entity detail.

IMPORTANT: Ensure `_POSIX_C_SOURCE 200809L` is defined at the top of tab_ecs.c (already present) for clock_gettime.
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with CELS app. Test the full workflow:
1. Navigate to ECS tab, expand Systems section
2. Select a system entity -> inspector shows metadata (phase, status, match count, timing, component access)
3. After entity detail loads, matched entities appear below component access list
4. Switch focus to right panel (right arrow), scroll through matched entities with j/k
5. Press Enter on a matched entity -> cursor jumps to that entity in the Entities section (left panel)
6. Entities section is auto-expanded if it was collapsed
7. If target entity not found, footer shows "Entity not found" for 3 seconds
  </verify>
  <done>
System detail inspector shows full metadata (phase, status, match count, timing, tables, path, component access, matched entities). Matched entity list built by filtering entities that share the system's query components. Cross-navigation via Enter on matched entity: uncollapse Entities section, move cursor, update selection, switch focus to left panel. Footer notification on entity-not-found.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero warnings
2. System detail inspector renders correctly for all system types (with/without query, with/without timing)
3. Matched entity list is populated and scrollable
4. Cross-navigation jumps to correct entity in tree
5. Cross-navigation uncollapse target section
6. Entity-not-found shows footer message
7. No memory leaks (matches array freed after each use)
</verification>

<success_criteria>
- System entity selection shows full metadata inspector (phase, status, match count, timing, component access)
- Matched entities listed based on system's component access pattern
- Enter on matched entity cross-navigates to Entities section
- Cross-navigation uncollapse Entities (and Compositions) sections if needed
- Footer message "Entity not found" shown when target is missing
- Right panel scroll works for matched entity list (j/k, PgUp/PgDn)
- All system types handled: systems with queries (show matches), task systems (show "No matches")
</success_criteria>

<output>
After completion, create `.planning/phases/04-systems-and-pipeline/04-03-SUMMARY.md`
</output>
