---
phase: 04-systems-and-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - tools/cels-debug/src/tabs/tab_ecs.c
autonomous: true

must_haves:
  truths:
    - "System entity nodes are enriched with match count and disabled status from pipeline stats each draw cycle"
    - "Phase sub-headers in the tree are populated with correct phase names and system counts from entity classification"
    - "Inspector shows pipeline visualization when a phase sub-header is selected"
    - "Inspector shows summary stats when the Systems CELS-C header is selected"
  artifacts:
    - path: "tools/cels-debug/src/tabs/tab_ecs.c"
      provides: "System enrichment from pipeline stats, pipeline viz inspector, systems summary inspector"
      contains: "enrich_systems_with_pipeline"
  key_links:
    - from: "tools/cels-debug/src/tabs/tab_ecs.c"
      to: "system_registry_t"
      via: "enrichment merges pipeline stats into entity nodes"
      pattern: "system_registry"
    - from: "tools/cels-debug/src/tabs/tab_ecs.c"
      to: "tree_view_set_phases"
      via: "enrichment calls set_phases before rebuild"
      pattern: "tree_view_set_phases"
    - from: "tools/cels-debug/src/tabs/tab_ecs.c"
      to: "tree_view phase sub-header selection"
      via: "inspector checks if selected row is phase sub-header"
      pattern: "phase_group.*>=.*0"
---

<objective>
Wire system enrichment from pipeline stats into entity nodes and tree_view phase data. Add pipeline visualization and systems summary inspector branches.

Purpose: Plan 02 built the tree_view infrastructure for phase sub-headers and enriched rendering. This plan connects it to live data (enrichment from system_registry + entity classification) and adds the two inspector branches that render when phase/section headers are selected.
Output: Fully functional Systems section with enriched data + pipeline viz and summary inspectors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@tools/cels-debug/.planning/PROJECT.md
@tools/cels-debug/.planning/ROADMAP.md
@tools/cels-debug/.planning/STATE.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-RESEARCH.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-CONTEXT.md
@tools/cels-debug/.planning/phases/04-systems-and-pipeline/04-02-SUMMARY.md

@tools/cels-debug/src/tabs/tab_ecs.c
@tools/cels-debug/src/data_model.h
@tools/cels-debug/src/tui.h
@tools/cels-debug/src/tree_view.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: System enrichment function and wiring into draw cycle</name>
  <files>
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
Add the canonical phase ordering array at the top of tab_ecs.c (file-local static). This is a duplicate of the conceptual Flecs phase order used for sorting -- tree_view.c has its own phase_color_pair() for rendering, tab_ecs.c needs the order for sorting. Keep them as separate concerns with a sync comment:

```c
/* Canonical Flecs pipeline phase execution order.
 * Keep in sync with phase_color_pair() in tree_view.c. */
static const char *PHASE_ORDER[] = {
    "OnStart", "OnLoad", "PostLoad", "PreUpdate", "OnUpdate",
    "OnValidate", "PostUpdate", "PreStore", "OnStore", "PostFrame",
};
static const int PHASE_ORDER_COUNT = 10;
```

Add a static `phase_color_pair()` duplicate in tab_ecs.c (needed for inspector rendering). This is a small lookup function; duplicating avoids header changes:

```c
/* Phase name to color pair. Duplicated from tree_view.c for inspector use.
 * Keep in sync with tree_view.c phase_color_pair(). */
static int phase_color_pair(const char *phase) {
    if (!phase) return CP_PHASE_CUSTOM;
    if (strcmp(phase, "OnLoad") == 0)      return CP_PHASE_ONLOAD;
    if (strcmp(phase, "PostLoad") == 0)    return CP_PHASE_POSTLOAD;
    if (strcmp(phase, "PreUpdate") == 0)   return CP_PHASE_PREUPDATE;
    if (strcmp(phase, "OnUpdate") == 0)    return CP_PHASE_ONUPDATE;
    if (strcmp(phase, "OnValidate") == 0)  return CP_PHASE_ONVALIDATE;
    if (strcmp(phase, "PostUpdate") == 0)  return CP_PHASE_POSTUPDATE;
    if (strcmp(phase, "PreStore") == 0)    return CP_PHASE_PRESTORE;
    if (strcmp(phase, "OnStore") == 0)     return CP_PHASE_ONSTORE;
    if (strcmp(phase, "PostFrame") == 0)   return CP_PHASE_POSTFRAME;
    if (strcmp(phase, "OnStart") == 0)     return CP_PHASE_ONLOAD;
    return CP_PHASE_CUSTOM;
}
```

Add `enrich_systems_with_pipeline()`:
```c
/* Enrich system entity nodes with data from pipeline stats.
 * Matches by leaf name (fast, sufficient for small apps).
 * Also builds the phase list for tree_view phase sub-headers. */
static void enrich_systems_with_pipeline(entity_list_t *list,
                                          system_registry_t *reg,
                                          tree_view_t *tree) {
    if (!list || !reg || reg->count == 0) {
        tree_view_set_phases(tree, NULL, NULL, 0);
        return;
    }

    /* Build ordered phase list from system entities (using entity tags) */
    char *found_phases[32];
    int found_counts[32];
    int found_count = 0;

    for (int i = 0; i < list->root_count; i++) {
        entity_node_t *node = list->roots[i];
        if (node->entity_class != ENTITY_CLASS_SYSTEM) continue;
        if (!node->class_detail) continue;

        bool exists = false;
        for (int p = 0; p < found_count; p++) {
            if (strcmp(found_phases[p], node->class_detail) == 0) {
                found_counts[p]++;
                exists = true;
                break;
            }
        }
        if (!exists && found_count < 32) {
            found_phases[found_count] = node->class_detail;
            found_counts[found_count] = 1;
            found_count++;
        }
    }

    /* Sort phases by canonical execution order (insertion sort, max 32) */
    for (int i = 1; i < found_count; i++) {
        char *phase = found_phases[i];
        int count = found_counts[i];
        int order_i = PHASE_ORDER_COUNT;
        for (int k = 0; k < PHASE_ORDER_COUNT; k++) {
            if (strcmp(phase, PHASE_ORDER[k]) == 0) { order_i = k; break; }
        }
        int j = i - 1;
        while (j >= 0) {
            int order_j = PHASE_ORDER_COUNT;
            for (int k = 0; k < PHASE_ORDER_COUNT; k++) {
                if (strcmp(found_phases[j], PHASE_ORDER[k]) == 0) { order_j = k; break; }
            }
            if (order_j > order_i) {
                found_phases[j + 1] = found_phases[j];
                found_counts[j + 1] = found_counts[j];
                j--;
            } else break;
        }
        found_phases[j + 1] = phase;
        found_counts[j + 1] = count;
    }

    tree_view_set_phases(tree, found_phases, found_counts, found_count);

    /* Enrich each system entity with pipeline stats (match by leaf name) */
    for (int i = 0; i < list->root_count; i++) {
        entity_node_t *node = list->roots[i];
        if (node->entity_class != ENTITY_CLASS_SYSTEM) continue;
        if (!node->name) continue;

        for (int s = 0; s < reg->count; s++) {
            if (reg->systems[s].name &&
                strcmp(reg->systems[s].name, node->name) == 0) {
                node->system_match_count = reg->systems[s].matched_entity_count;
                node->disabled = reg->systems[s].disabled;
                break;
            }
        }
    }
}
```

Wire into `tab_ecs_draw()`, after `classify_all_entities()` and `annotate_component_entities()`, before `tree_view_rebuild_visible()`:
```c
classify_all_entities(state->entity_list);
annotate_component_entities(state->entity_list, state->component_registry);
enrich_systems_with_pipeline(state->entity_list, state->system_registry, &es->tree);
tree_view_rebuild_visible(&es->tree, state->entity_list);
```
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with a CELS app. Navigate to ECS tab, expand Systems section. Verify:
1. Phase sub-headers appear (OnUpdate, OnStore, etc.) with system counts
2. Enter on phase sub-header toggles collapse
3. System names show with color-coded [Phase] tags
4. Match counts appear as (N) on system rows
5. Disabled systems (if any) appear dimmed
6. Empty phases are not shown
  </verify>
  <done>
enrich_systems_with_pipeline() enriches system entity nodes with match count and disabled status from pipeline stats (matched by leaf name). Builds sorted phase list from entity classification and passes to tree_view_set_phases(). Wired into tab_ecs_draw() before tree rebuild. PHASE_ORDER and phase_color_pair() defined in tab_ecs.c with sync comments pointing to tree_view.c counterpart.
  </done>
</task>

<task type="auto">
  <name>Task 2: Inspector branches for pipeline visualization and systems summary</name>
  <files>
    tools/cels-debug/src/tabs/tab_ecs.c
  </files>
  <action>
Add two new inspector rendering branches in `tab_ecs_draw()`. These go in the right panel rendering section, BEFORE the existing `sel && sel->entity_class == ENTITY_CLASS_COMPONENT` check.

The inspector dispatch logic should now be:

```c
/* Right panel: context-sensitive inspector */
entity_node_t *sel = tree_view_selected(&es->tree);
display_row_t *cur_row = NULL;
if (es->tree.rows && es->tree.scroll.cursor >= 0 &&
    es->tree.scroll.cursor < es->tree.row_count) {
    cur_row = &es->tree.rows[es->tree.scroll.cursor];
}
WINDOW *rwin = es->panel.right;
int rh = getmaxy(rwin) - 2;
int rw = getmaxx(rwin) - 2;

if (cur_row && !cur_row->node && cur_row->section_idx == ENTITY_CLASS_SYSTEM) {
    if (cur_row->phase_group >= 0) {
        /* --- Branch: Phase sub-header selected -> Pipeline visualization --- */
        draw_pipeline_viz(rwin, rh, rw, &es->tree, cur_row->phase_group, state);
    } else {
        /* --- Branch: Systems section header selected -> Summary stats --- */
        draw_systems_summary(rwin, rh, rw, state);
    }
} else if (sel && sel->entity_class == ENTITY_CLASS_COMPONENT) {
    /* ... existing component inspector ... */
} else if (sel && state->entity_detail) {
    /* ... existing entity detail inspector ... */
} else if (!sel) {
    /* ... existing "select an entity" placeholder ... */
} else {
    /* ... existing "Loading..." placeholder ... */
}
```

Implement `draw_pipeline_viz()`:
```c
static void draw_pipeline_viz(WINDOW *rwin, int rh, int rw,
                               tree_view_t *tree, int selected_phase,
                               const app_state_t *state) {
    /* Title */
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, 1, 1, "Pipeline Execution Order");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);

    /* Separator */
    wattron(rwin, A_DIM);
    wmove(rwin, 2, 1);
    for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
    wattroff(rwin, A_DIM);

    int row = 4;
    #define PIPE_VERT  "\xe2\x94\x82"
    #define PIPE_ARROW "\xe2\x86\x93"

    double total_time = 0.0;
    int total_systems = 0;

    for (int p = 0; p < tree->phase_count; p++) {
        if (row >= rh) break;

        bool is_selected = (p == selected_phase);
        int cp = phase_color_pair(tree->phase_names[p]);

        if (is_selected) wattron(rwin, A_REVERSE);

        /* Phase name in color */
        wattron(rwin, COLOR_PAIR(cp) | A_BOLD);
        mvwprintw(rwin, row, 3, "%-14s", tree->phase_names[p]);
        wattroff(rwin, COLOR_PAIR(cp) | A_BOLD);

        /* System count */
        int sys_count = tree->phase_system_counts[p];
        wprintw(rwin, " %d system%s", sys_count, sys_count == 1 ? "" : "s");
        total_systems += sys_count;

        /* Timing: sum time_spent_ms for systems in this phase */
        if (state->system_registry && state->entity_list) {
            double phase_time = 0.0;
            for (int s = 0; s < state->system_registry->count; s++) {
                system_info_t *si = &state->system_registry->systems[s];
                /* Find entity node for this system to check its phase */
                for (int e = 0; e < state->entity_list->root_count; e++) {
                    entity_node_t *en = state->entity_list->roots[e];
                    if (en->entity_class == ENTITY_CLASS_SYSTEM &&
                        en->name && si->name &&
                        strcmp(en->name, si->name) == 0 &&
                        en->class_detail &&
                        strcmp(en->class_detail, tree->phase_names[p]) == 0) {
                        phase_time += si->time_spent_ms;
                        break;
                    }
                }
            }
            if (phase_time > 0.0) {
                wprintw(rwin, "   %.1fms", phase_time);
                total_time += phase_time;
            }
        }

        if (is_selected) wattroff(rwin, A_REVERSE);
        row++;

        /* Draw connector to next phase */
        if (p < tree->phase_count - 1 && row + 1 < rh) {
            wattron(rwin, A_DIM);
            mvwprintw(rwin, row, 6, PIPE_VERT);
            row++;
            mvwprintw(rwin, row, 6, PIPE_ARROW);
            row++;
            wattroff(rwin, A_DIM);
        }
    }

    /* Total summary */
    row += 1;
    if (row < rh) {
        wattron(rwin, A_DIM);
        wmove(rwin, row, 1);
        for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
        wattroff(rwin, A_DIM);
        row++;
    }
    if (row < rh) {
        mvwprintw(rwin, row, 3, "Total: %d system%s",
                  total_systems, total_systems == 1 ? "" : "s");
        if (total_time > 0.0) {
            wprintw(rwin, ", %.1fms/frame", total_time);
        }
    }
}
```

Implement `draw_systems_summary()`:
```c
static void draw_systems_summary(WINDOW *rwin, int rh, int rw,
                                  const app_state_t *state) {
    /* Title */
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, 1, 1, "Systems Overview");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);

    /* Separator */
    wattron(rwin, A_DIM);
    wmove(rwin, 2, 1);
    for (int x = 0; x < rw; x++) waddch(rwin, ACS_HLINE);
    wattroff(rwin, A_DIM);

    if (!state->entity_list) {
        wattron(rwin, A_DIM);
        mvwprintw(rwin, 4, 3, "Waiting for data...");
        wattroff(rwin, A_DIM);
        return;
    }

    /* Count totals */
    int total = 0, enabled = 0, disabled = 0;
    for (int i = 0; i < state->entity_list->root_count; i++) {
        entity_node_t *n = state->entity_list->roots[i];
        if (n->entity_class != ENTITY_CLASS_SYSTEM) continue;
        total++;
        if (n->disabled) disabled++;
        else enabled++;
    }

    int row = 4;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 3, "Total Systems");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    wattron(rwin, COLOR_PAIR(CP_JSON_NUMBER));
    mvwprintw(rwin, row, 20, "%d", total);
    wattroff(rwin, COLOR_PAIR(CP_JSON_NUMBER));

    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 3, "Enabled");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    wattron(rwin, COLOR_PAIR(CP_CONNECTED));
    mvwprintw(rwin, row, 20, "%d", enabled);
    wattroff(rwin, COLOR_PAIR(CP_CONNECTED));

    row++;
    wattron(rwin, COLOR_PAIR(CP_JSON_KEY));
    mvwprintw(rwin, row, 3, "Disabled");
    wattroff(rwin, COLOR_PAIR(CP_JSON_KEY));
    if (disabled > 0) {
        wattron(rwin, COLOR_PAIR(CP_DISCONNECTED));
        mvwprintw(rwin, row, 20, "%d", disabled);
        wattroff(rwin, COLOR_PAIR(CP_DISCONNECTED));
    } else {
        wattron(rwin, A_DIM);
        mvwprintw(rwin, row, 20, "0");
        wattroff(rwin, A_DIM);
    }

    /* Phase distribution */
    row += 2;
    wattron(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    mvwprintw(rwin, row, 1, "Phase Distribution");
    wattroff(rwin, COLOR_PAIR(CP_COMPONENT_HEADER) | A_BOLD);
    row++;

    char *phases[32];
    int pcounts[32];
    int pcount = 0;

    for (int i = 0; i < state->entity_list->root_count; i++) {
        entity_node_t *n = state->entity_list->roots[i];
        if (n->entity_class != ENTITY_CLASS_SYSTEM) continue;
        const char *ph = n->class_detail ? n->class_detail : "Unknown";
        bool found = false;
        for (int p = 0; p < pcount; p++) {
            if (strcmp(phases[p], ph) == 0) { pcounts[p]++; found = true; break; }
        }
        if (!found && pcount < 32) {
            phases[pcount] = (char *)ph;
            pcounts[pcount] = 1;
            pcount++;
        }
    }

    for (int p = 0; p < pcount && row < rh; p++) {
        int cp = phase_color_pair(phases[p]);
        wattron(rwin, COLOR_PAIR(cp));
        mvwprintw(rwin, row, 3, "%-14s", phases[p]);
        wattroff(rwin, COLOR_PAIR(cp));
        wprintw(rwin, " %d", pcounts[p]);
        row++;
    }
}
```
  </action>
  <verify>
Build compiles: `cd /home/cachy/workspaces/libs/cels && cmake --build build --target cels_debug 2>&1 | tail -10`.
Run with CELS app. Navigate to ECS tab, expand Systems section:
1. Select "Systems" header -> inspector shows summary (total, enabled, disabled, phase distribution)
2. Select a phase sub-header (e.g., OnUpdate) -> inspector shows pipeline visualization with phases connected by vertical lines and arrows, selected phase highlighted
3. Timing data appears next to phases if pipeline stats are available
4. Total line at bottom of pipeline viz shows aggregate count and timing
  </verify>
  <done>
Inspector panel renders pipeline visualization when phase sub-header is selected (vertical flow with box-drawing connectors, color-coded phases, timing data, highlighted selected phase). Inspector renders systems summary when Systems header is selected (total/enabled/disabled counts, phase distribution). Both branches use live data from entity classification and pipeline stats. phase_color_pair() and PHASE_ORDER defined locally in tab_ecs.c with sync comments.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero warnings
2. Systems section shows phase sub-headers in canonical execution order
3. Phase sub-headers populated with correct system counts
4. System rows enriched with match count and disabled status
5. Inspector: phase header -> pipeline viz; Systems header -> summary stats
6. Timing data displays in pipeline viz
7. Navigation through phase headers works (j/k, Enter to collapse)
</verification>

<success_criteria>
- enrich_systems_with_pipeline() called each draw cycle before tree rebuild
- Entity nodes enriched with system_match_count and disabled from pipeline stats
- Phase list sorted by canonical Flecs execution order
- tree_view_set_phases() called with sorted phase data
- Pipeline visualization uses box-drawing characters with vertical flow
- Systems summary shows total/enabled/disabled counts and phase distribution
- All phase names color-coded (OnUpdate=green, OnStore=red, etc.)
- PHASE_ORDER and phase_color_pair() in tab_ecs.c with sync comments referencing tree_view.c
</success_criteria>

<output>
After completion, create `.planning/phases/04-systems-and-pipeline/04-03-SUMMARY.md`
</output>
