---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/tui.h
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/tui.c
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/main.c
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/CMakeLists.txt
autonomous: false

must_haves:
  truths:
    - "TUI launches with header, content area, and footer visible"
    - "Header shows 'Connected' (green), 'Disconnected' (red), or 'Reconnecting' (yellow) based on HTTP poll result"
    - "Content area shows entity count and FPS from /stats/world"
    - "Footer shows 'q: quit' help text"
    - "Pressing q exits cleanly, terminal is restored to normal"
    - "Pressing Ctrl+C exits cleanly, terminal is restored to normal"
    - "Terminal is not left corrupted if the process is killed (SIGTERM)"
    - "Screen layout adapts when terminal is resized"
    - "Data refreshes every 500ms via HTTP polling"
  artifacts:
    - path: "tools/cels-debug/src/tui.h"
      provides: "TUI init/fini/render/resize interface"
      exports: ["tui_init", "tui_fini", "tui_render", "tui_resize"]
    - path: "tools/cels-debug/src/tui.c"
      provides: "ncurses implementation with signal handlers, window layout, color pairs"
      contains: "signal_handler"
    - path: "tools/cels-debug/src/main.c"
      provides: "Main event loop: input -> poll -> render cycle"
      contains: "g_running"
  key_links:
    - from: "main.c"
      to: "tui.h"
      via: "tui_init/tui_render/tui_fini calls"
      pattern: "tui_render"
    - from: "main.c"
      to: "http_client.h"
      via: "http_get on timer"
      pattern: "http_get.*stats/world"
    - from: "main.c"
      to: "json_parser.h"
      via: "json_parse_world_stats on HTTP 200"
      pattern: "json_parse_world_stats"
    - from: "tui.c"
      to: "signal handlers"
      via: "signal(SIGINT/SIGTERM/SIGSEGV, handler) calling endwin()"
      pattern: "signal.*SIGINT"
    - from: "tui.c"
      to: "atexit"
      via: "atexit(cleanup) as safety net"
      pattern: "atexit"
---

<objective>
ncurses TUI shell and main event loop: A live terminal interface that polls /stats/world every 500ms, displays connection status in the header, entity count and FPS in the content area, and exits cleanly on q/Ctrl+C with the terminal always restored.

Purpose: This is the user-facing deliverable of Phase 01. After this plan, cels-debug is a functional connected status monitor -- the foundation every future tab will build on.
Output: tui.h/.c with ncurses rendering, main.c with the complete MVC event loop.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/PROJECT.md
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/ROADMAP.md
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/phases/01-foundation/RESEARCH.md
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/phases/01-foundation/01-01-SUMMARY.md
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TUI module with ncurses init, signal handlers, and window layout</name>
  <files>
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/tui.h
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/tui.c
    /home/cachy/workspaces/libs/cels/tools/cels-debug/CMakeLists.txt
  </files>
  <action>
  Create the TUI module:

  **1. `src/tui.h`:**

  ```c
  #ifndef CELS_DEBUG_TUI_H
  #define CELS_DEBUG_TUI_H

  #include "data_model.h"
  #include "http_client.h"  // for connection_state_t

  // Initialize ncurses, signal handlers, atexit, color pairs, windows.
  // Call once at startup. Sets up:
  //   - initscr, cbreak, noecho, keypad, curs_set(0)
  //   - timeout(100) for non-blocking getch
  //   - Color pairs: 1=green(connected), 2=red(disconnected), 3=yellow(reconnecting), 4=cyan(labels)
  //   - Signal handlers for SIGINT, SIGTERM, SIGSEGV, SIGABRT -> endwin + _exit
  //   - atexit(endwin) safety net
  //   - Three windows: header (1 line), content (LINES-2), footer (1 line)
  void tui_init(void);

  // Shutdown ncurses, destroy windows, call endwin.
  void tui_fini(void);

  // Render one frame: header with connection status, content with stats, footer with help.
  // snapshot may be NULL (no data yet) -- display "Waiting for data..." in content.
  // Uses wnoutrefresh() on all windows, then doupdate() once (no flicker).
  void tui_render(const world_snapshot_t *snapshot, connection_state_t conn_state);

  // Recalculate window sizes from LINES/COLS. Call on KEY_RESIZE.
  void tui_resize(void);

  #endif // CELS_DEBUG_TUI_H
  ```

  **2. `src/tui.c`:**

  Implement the full TUI module. Key requirements:

  **Signal handlers:** Install for SIGINT, SIGTERM, SIGSEGV, SIGABRT. Each calls `endwin()` then `_exit(1)`. This prevents terminal corruption on any crash or Ctrl+C. Also register `atexit()` with a cleanup function that calls `endwin()` as a safety net for normal `exit()` calls.

  **ncurses init sequence:**
  ```c
  initscr();
  cbreak();
  noecho();
  keypad(stdscr, TRUE);
  curs_set(0);            // Hide cursor
  timeout(100);           // getch returns ERR after 100ms
  ```

  **Color pairs** (if terminal supports color):
  - Pair 1: COLOR_GREEN on default (-1) -- Connected status
  - Pair 2: COLOR_RED on default -- Disconnected status
  - Pair 3: COLOR_YELLOW on default -- Reconnecting status
  - Pair 4: COLOR_CYAN on default -- Labels and UI chrome

  **Window layout** -- three non-overlapping windows derived from LINES/COLS:
  - `win_header`: 1 line at row 0, full width. Shows: `cels-debug | <status>`
  - `win_content`: LINES-2 lines starting at row 1, full width. Shows stats or "Waiting for data..."
  - `win_footer`: 1 line at last row, full width. Shows: `q: quit`

  **Render function (`tui_render`):**
  1. Clear all three windows with `werase()`
  2. Header: Print "cels-debug" at left, then " | " then connection status string with appropriate color attribute:
     - CONN_CONNECTED: "Connected" in green (color pair 1)
     - CONN_DISCONNECTED: "Disconnected" in red (color pair 2)
     - CONN_RECONNECTING: "Reconnecting..." in yellow (color pair 3)
  3. Content: If snapshot is NULL, print "Waiting for data..." centered. If snapshot exists, print:
     ```
     Entities:   42
     FPS:        60.0
     Frame time: 16.67 ms
     Systems:    5
     ```
     Use color pair 4 (cyan) for labels, default for values. Start at row 1, col 2 of win_content.
  4. Footer: Print "q: quit" at left in dim/default color.
  5. Call `wnoutrefresh()` on each window (NOT wrefresh -- Pitfall P2)
  6. Call `doupdate()` exactly once

  **Resize function (`tui_resize`):**
  1. Call `endwin()` then `refresh()` to get updated LINES/COLS
  2. Delete existing windows with `delwin()`
  3. Recreate windows with new LINES/COLS dimensions

  IMPORTANT anti-patterns to avoid:
  - Do NOT call `wrefresh()` on individual windows -- use `wnoutrefresh()` + `doupdate()`
  - Do NOT hardcode terminal dimensions -- always use LINES and COLS
  - Do NOT use `nodelay()` -- use `timeout(100)` which gives a good balance of input responsiveness and CPU usage

  **3. Update `CMakeLists.txt`** -- Add tui.c to the source list:
  ```cmake
  add_executable(cels-debug
      src/main.c
      src/http_client.c
      src/json_parser.c
      src/data_model.c
      src/tui.c
  )
  ```
  </action>
  <verify>
  Build compiles:
  ```bash
  cd /home/cachy/workspaces/libs/cels/build
  cmake --build . --target cels-debug 2>&1 | tail -10
  ```
  No errors. The TUI module compiles against ncurses headers.
  </verify>
  <done>tui.h/.c exist with init/fini/render/resize functions. Signal handlers cover SIGINT/SIGTERM/SIGSEGV/SIGABRT. atexit registered. Three ncurses windows created. Render uses wnoutrefresh + doupdate. Compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Replace main.c with full MVC event loop</name>
  <files>
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/main.c
  </files>
  <action>
  Replace the data pipeline test main.c with the complete event loop. This is the final main.c for Phase 01.

  **`src/main.c`** structure:

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  #include <ncurses.h>

  #include "http_client.h"
  #include "json_parser.h"
  #include "data_model.h"
  #include "tui.h"

  #define POLL_INTERVAL_MS 500

  static volatile int g_running = 1;
  ```

  **main() function:**

  1. Initialize subsystems in order: `tui_init()` first (registers signal handlers), then `http_client_init()`. If curl init fails, call `tui_fini()` and exit 1.

  2. Declare state variables:
     - `world_snapshot_t *snapshot = NULL;`
     - `connection_state_t conn_state = CONN_DISCONNECTED;`
     - `struct timespec last_poll = {0, 0};`
     - `const char *url = "http://localhost:27750/stats/world";`

  3. Main loop (`while (g_running)`):

     **Step 1 - Input:** Call `getch()`. Handle:
     - `'q'` or `'Q'`: Set `g_running = 0`
     - `KEY_RESIZE`: Call `tui_resize()`
     - `ERR`: No input (timeout expired), continue

     **Step 2 - Poll on timer:** Use `clock_gettime(CLOCK_MONOTONIC)` to measure elapsed time since `last_poll`. If elapsed >= POLL_INTERVAL_MS:
     - Call `http_get(curl, url)`
     - If status == 200: parse with `json_parse_world_stats()`, swap snapshots (free old, assign new)
     - Update connection state with `connection_state_update()`
     - Free response with `http_response_free()`
     - Update `last_poll = now`

     **Step 3 - Render:** Call `tui_render(snapshot, conn_state)`

  4. Cleanup: `world_snapshot_free(snapshot)`, `http_client_fini(curl)`, `tui_fini()`

  5. Return 0.

  Note: `tui_init()` sets `timeout(100)` on getch, which means the loop runs at ~10fps when idle. This is the right balance between CPU usage and input responsiveness. HTTP polling happens independently on the 500ms timer, not on every loop iteration.

  Note: The `g_running` flag should be `volatile int` so signal handlers can set it to 0. However, the signal handlers in tui.c call `_exit()` directly, so this is a belt-and-suspenders approach -- either the signal handler exits immediately, or g_running stops the loop.
  </action>
  <verify>
  Build and run:
  ```bash
  cd /home/cachy/workspaces/libs/cels/build
  cmake --build . --target cels-debug 2>&1 | tail -5
  ./cels-debug
  ```

  **Without a CELS app running:**
  - TUI launches with header, content, footer visible
  - Header shows "cels-debug | Disconnected" (red)
  - Content shows "Waiting for data..."
  - Footer shows "q: quit"
  - Pressing q exits, terminal is normal
  - Run again, press Ctrl+C -- terminal is normal

  **With a CELS app running (built with -DCELS_DEBUG=ON):**
  - Header shows "cels-debug | Connected" (green)
  - Content shows entity count, FPS, frame time, system count
  - Values update every ~500ms
  - Kill the CELS app while cels-debug is running:
    - Header transitions to "cels-debug | Reconnecting..." (yellow)
    - After another failed poll: "cels-debug | Disconnected" (red)
  - Restart CELS app: header returns to "Connected" (green)

  **Terminal safety test:**
  ```bash
  ./cels-debug &
  sleep 1
  kill $!
  echo "Terminal OK if you can see this"
  ```
  Expected: "Terminal OK if you can see this" is visible and terminal is not corrupted.
  </verify>
  <done>
  main.c implements the complete MVC event loop:
  - Input handling: q quits, KEY_RESIZE recalculates layout
  - Timer-based polling: HTTP GET every 500ms via clock_gettime
  - Render: tui_render called every loop iteration with current snapshot and connection state
  - Clean shutdown: snapshot freed, curl cleaned up, ncurses restored
  - Terminal never corrupted on any exit path (q, Ctrl+C, SIGTERM, SIGSEGV)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete Phase 01 TUI: cels-debug connects to localhost:27750, polls /stats/world every 500ms, and displays live entity count and FPS in a ncurses terminal interface with connection status indicator and clean exit handling.
  </what-built>
  <how-to-verify>
  1. Build and run against a CELS app:
     ```bash
     cd /home/cachy/workspaces/libs/cels/build
     cmake .. -DCELS_BUILD_TOOLS=ON -DCELS_DEBUG=ON
     cmake --build .
     ```
  2. Start a CELS app (e.g., the app example) in one terminal
  3. Start cels-debug in another terminal: `./cels-debug`
  4. Verify:
     - Header shows "cels-debug | Connected" in green
     - Content shows entity count, FPS, frame time, systems with real values
     - Values update every ~500ms (visible counter changes)
  5. Kill the CELS app. Verify:
     - Header changes to "Reconnecting..." then "Disconnected"
     - No crash, TUI stays running
  6. Restart the CELS app. Verify:
     - Header returns to "Connected", stats resume
  7. Press q. Verify terminal is clean.
  8. Run again, press Ctrl+C. Verify terminal is clean.
  9. Resize the terminal window while cels-debug is running. Verify layout adapts.
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Phase 01 success criteria from ROADMAP.md:

1. CMake project builds with ncursesw, libcurl, and yyjson dependencies resolved
   - Verify: `cmake --build . --target cels-debug` succeeds

2. TUI launches, displays header/content/footer layout, and exits cleanly on q or Ctrl+C
   - Verify: Run cels-debug, visually confirm three-region layout, press q, confirm terminal clean

3. HTTP client polls localhost:27750/stats/world and parses JSON response into data model structs
   - Verify: With CELS app running, stats values appear in content area and update every 500ms

4. Header shows connection status: Connected, Disconnected, or Reconnecting
   - Verify: Start/stop CELS app while cels-debug runs, observe status transitions

5. Content area displays entity count and FPS from /stats/world response
   - Verify: Entity count and FPS values match what flecs explorer shows at localhost:27750

6. Terminal is never left in corrupted state
   - Verify: q exit, Ctrl+C exit, SIGTERM (kill) exit all leave terminal usable

7. Prerequisite met: ECS_IMPORT(FlecsStats) added behind #ifdef CELS_DEBUG in CELS runtime
   - Verify: `grep -n "FlecsStats" src/cels.cpp` shows the import inside #ifdef CELS_DEBUG
</verification>

<success_criteria>
- cels-debug TUI launches and displays header/content/footer layout
- Header shows correct connection status with color coding (green/red/yellow)
- Content displays entity count, FPS, frame time, system count from live /stats/world data
- Data refreshes every ~500ms
- Footer shows "q: quit"
- Clean exit on q, Ctrl+C, and SIGTERM (terminal never corrupted)
- Layout adapts on terminal resize
- Graceful behavior when target app is not running (shows Disconnected, no crash)
- Connection state transitions correctly: Disconnected -> Connected -> Reconnecting -> Disconnected -> Connected
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
