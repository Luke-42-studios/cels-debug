---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/http_client.h
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/http_client.c
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/json_parser.h
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/json_parser.c
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/data_model.h
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/data_model.c
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/src/main.c
  - /home/cachy/workspaces/libs/cels/tools/cels-debug/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "HTTP client connects to localhost:27750 and receives response body"
    - "HTTP client returns status -1 (not crash) when target is not running"
    - "Connection state transitions: DISCONNECTED -> CONNECTED on success, CONNECTED -> RECONNECTING on failure"
    - "JSON parser extracts entity_count, fps, frame_time_ms from /stats/world response"
    - "world_snapshot_t is allocated and freed without memory leaks"
  artifacts:
    - path: "tools/cels-debug/src/http_client.h"
      provides: "HTTP client interface: init/fini, get, response type, connection state enum"
      exports: ["http_client_init", "http_client_fini", "http_get", "http_response_free", "connection_state_t"]
    - path: "tools/cels-debug/src/http_client.c"
      provides: "libcurl implementation with 200ms timeout"
      contains: "CURLOPT_TIMEOUT_MS"
    - path: "tools/cels-debug/src/json_parser.h"
      provides: "JSON parse interface for /stats/world"
      exports: ["json_parse_world_stats"]
    - path: "tools/cels-debug/src/json_parser.c"
      provides: "yyjson implementation extracting latest gauge values"
      contains: "yyjson_doc_get_root"
    - path: "tools/cels-debug/src/data_model.h"
      provides: "world_snapshot_t struct definition"
      exports: ["world_snapshot_t", "world_snapshot_create", "world_snapshot_free"]
    - path: "tools/cels-debug/src/data_model.c"
      provides: "Snapshot alloc/free implementation"
      contains: "world_snapshot_create"
  key_links:
    - from: "json_parser.c"
      to: "data_model.h"
      via: "#include and world_snapshot_create"
      pattern: "world_snapshot_create"
    - from: "http_client.c"
      to: "libcurl"
      via: "curl_easy_perform with CURLOPT_TIMEOUT_MS=200"
      pattern: "CURLOPT_TIMEOUT_MS.*200"
    - from: "json_parser.c"
      to: "yyjson"
      via: "yyjson_read and yyjson_doc_get_root"
      pattern: "yyjson_read"
---

<objective>
HTTP client, JSON parser, and data model: libcurl fetches /stats/world, yyjson parses the response into a world_snapshot_t struct with entity_count, fps, and frame_time_ms.

Purpose: This is the data pipeline that feeds the TUI. Without working HTTP fetch and JSON parse, the TUI has nothing to display. The data model defines the contract between the network layer and the rendering layer.
Output: http_client.h/.c, json_parser.h/.c, data_model.h/.c -- a complete data pipeline from HTTP GET to typed C struct.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/PROJECT.md
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/ROADMAP.md
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/phases/01-foundation/RESEARCH.md
@/home/cachy/workspaces/libs/cels/tools/cels-debug/.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data model and HTTP client</name>
  <files>
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/data_model.h
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/data_model.c
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/http_client.h
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/http_client.c
  </files>
  <action>
  Create four files:

  **1. `src/data_model.h`** -- Snapshot struct and lifecycle:

  ```c
  #ifndef CELS_DEBUG_DATA_MODEL_H
  #define CELS_DEBUG_DATA_MODEL_H

  #include <stdint.h>

  // Snapshot of /stats/world response
  // Each poll produces a new snapshot; previous is freed atomically
  typedef struct world_snapshot {
      double entity_count;
      double fps;
      double frame_time_ms;   // performance.frame_time converted to ms
      double system_count;
      int64_t timestamp_ms;   // when this snapshot was taken
  } world_snapshot_t;

  world_snapshot_t *world_snapshot_create(void);
  void world_snapshot_free(world_snapshot_t *snap);

  #endif // CELS_DEBUG_DATA_MODEL_H
  ```

  **2. `src/data_model.c`** -- Alloc/free:

  ```c
  #include "data_model.h"
  #include <stdlib.h>
  #include <string.h>
  #include <time.h>

  world_snapshot_t *world_snapshot_create(void) {
      world_snapshot_t *snap = calloc(1, sizeof(world_snapshot_t));
      if (snap) {
          struct timespec ts;
          clock_gettime(CLOCK_MONOTONIC, &ts);
          snap->timestamp_ms = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
      }
      return snap;
  }

  void world_snapshot_free(world_snapshot_t *snap) {
      free(snap);
  }
  ```

  **3. `src/http_client.h`** -- HTTP client interface:

  ```c
  #ifndef CELS_DEBUG_HTTP_CLIENT_H
  #define CELS_DEBUG_HTTP_CLIENT_H

  #include <stddef.h>
  #include <curl/curl.h>

  // Connection state machine
  typedef enum {
      CONN_DISCONNECTED = 0,
      CONN_CONNECTED,
      CONN_RECONNECTING
  } connection_state_t;

  // HTTP response buffer
  typedef struct {
      char *data;
      size_t size;
  } http_buffer_t;

  // HTTP response (caller must call http_response_free)
  typedef struct {
      int status;          // HTTP status code, or -1 on network error
      http_buffer_t body;
  } http_response_t;

  // Initialize libcurl (call once at startup). Returns NULL on failure.
  CURL *http_client_init(void);

  // Perform HTTP GET. Timeout is 200ms (localhost only).
  // Caller must call http_response_free() on the result.
  http_response_t http_get(CURL *curl, const char *url);

  // Free response body memory.
  void http_response_free(http_response_t *resp);

  // Cleanup libcurl (call once at shutdown).
  void http_client_fini(CURL *curl);

  // Update connection state based on HTTP result.
  // Call after each http_get to transition the state machine:
  //   status 200 -> CONNECTED
  //   status != 200 && was CONNECTED -> RECONNECTING
  //   status != 200 && was DISCONNECTED/RECONNECTING -> DISCONNECTED
  connection_state_t connection_state_update(connection_state_t current, int http_status);

  #endif // CELS_DEBUG_HTTP_CLIENT_H
  ```

  **4. `src/http_client.c`** -- libcurl implementation:

  ```c
  #include "http_client.h"
  #include <stdlib.h>
  #include <string.h>

  static size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata) {
      size_t total = size * nmemb;
      http_buffer_t *buf = (http_buffer_t *)userdata;

      char *new_data = realloc(buf->data, buf->size + total + 1);
      if (!new_data) return 0;

      buf->data = new_data;
      memcpy(buf->data + buf->size, ptr, total);
      buf->size += total;
      buf->data[buf->size] = '\0';

      return total;
  }

  CURL *http_client_init(void) {
      curl_global_init(CURL_GLOBAL_DEFAULT);
      CURL *curl = curl_easy_init();
      if (!curl) return NULL;

      // Short timeouts -- localhost only, sub-ms round trip expected
      curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 200L);
      curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 200L);
      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
      // Prevent libcurl from installing its own signal handlers
      curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1L);

      return curl;
  }

  http_response_t http_get(CURL *curl, const char *url) {
      http_response_t resp = {0};
      http_buffer_t buf = {NULL, 0};

      curl_easy_setopt(curl, CURLOPT_URL, url);
      curl_easy_setopt(curl, CURLOPT_WRITEDATA, &buf);

      CURLcode res = curl_easy_perform(curl);
      if (res == CURLE_OK) {
          long http_code = 0;
          curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
          resp.status = (int)http_code;
          resp.body = buf;
      } else {
          resp.status = -1;
          free(buf.data);
      }

      return resp;
  }

  void http_response_free(http_response_t *resp) {
      free(resp->body.data);
      resp->body.data = NULL;
      resp->body.size = 0;
  }

  void http_client_fini(CURL *curl) {
      if (curl) curl_easy_cleanup(curl);
      curl_global_cleanup();
  }

  connection_state_t connection_state_update(connection_state_t current, int http_status) {
      if (http_status == 200) {
          return CONN_CONNECTED;
      }
      // Transition: was connected -> now reconnecting
      // Was disconnected/reconnecting -> stay disconnected
      if (current == CONN_CONNECTED) {
          return CONN_RECONNECTING;
      }
      return CONN_DISCONNECTED;
  }
  ```

  Key design decisions:
  - `CURLOPT_TIMEOUT_MS = 200` prevents blocking UI (Pitfall P1 from research)
  - `CURLOPT_NOSIGNAL = 1` prevents libcurl from installing signal handlers that conflict with our signal handlers
  - `connection_state_update()` is a pure function -- easy to test, easy to reason about
  - `http_response_t` owns the body buffer; caller frees via `http_response_free()`
  </action>
  <verify>
  Files exist and compile (build will be verified in Task 2):
  ```bash
  ls -la /home/cachy/workspaces/libs/cels/tools/cels-debug/src/data_model.{h,c}
  ls -la /home/cachy/workspaces/libs/cels/tools/cels-debug/src/http_client.{h,c}
  ```
  </verify>
  <done>data_model.h/.c and http_client.h/.c exist with correct types, interfaces, and implementations. connection_state_t enum has three states. world_snapshot_t has entity_count, fps, frame_time_ms, system_count fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create JSON parser and update build to verify data pipeline</name>
  <files>
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/json_parser.h
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/json_parser.c
    /home/cachy/workspaces/libs/cels/tools/cels-debug/src/main.c
    /home/cachy/workspaces/libs/cels/tools/cels-debug/CMakeLists.txt
  </files>
  <action>
  Create the JSON parser and update main.c + CMakeLists.txt for pipeline verification:

  **1. `src/json_parser.h`:**

  ```c
  #ifndef CELS_DEBUG_JSON_PARSER_H
  #define CELS_DEBUG_JSON_PARSER_H

  #include "data_model.h"
  #include <stddef.h>

  // Parse /stats/world JSON response into a world_snapshot_t.
  // Returns a newly allocated snapshot on success, NULL on parse failure.
  // Caller owns the returned snapshot and must call world_snapshot_free().
  //
  // The /stats/world response has metrics like:
  //   "entities.count": { "avg": [60 floats], "min": [...], "max": [...] }
  // We extract the LAST element of "avg" (most recent measurement).
  world_snapshot_t *json_parse_world_stats(const char *json, size_t len);

  #endif // CELS_DEBUG_JSON_PARSER_H
  ```

  **2. `src/json_parser.c`:**

  ```c
  #include "json_parser.h"
  #include <yyjson.h>

  // Extract the latest value from a gauge metric.
  // Flecs stats are 60-element circular buffers; last element is most recent.
  static double extract_latest_gauge(yyjson_val *root, const char *field) {
      yyjson_val *metric = yyjson_obj_get(root, field);
      if (!metric) return 0.0;

      yyjson_val *avg = yyjson_obj_get(metric, "avg");
      if (!avg || !yyjson_is_arr(avg)) return 0.0;

      size_t count = yyjson_arr_size(avg);
      if (count == 0) return 0.0;

      yyjson_val *last = yyjson_arr_get(avg, count - 1);
      if (!last) return 0.0;

      // yyjson_get_num handles both integer and real JSON number types
      // (flecs may serialize 42 or 42.0 depending on the metric)
      if (yyjson_is_num(last)) {
          return yyjson_get_num(last);
      }
      return 0.0;
  }

  world_snapshot_t *json_parse_world_stats(const char *json, size_t len) {
      if (!json || len == 0) return NULL;

      yyjson_doc *doc = yyjson_read(json, len, 0);
      if (!doc) return NULL;

      yyjson_val *root = yyjson_doc_get_root(doc);
      if (!root || !yyjson_is_obj(root)) {
          yyjson_doc_free(doc);
          return NULL;
      }

      world_snapshot_t *snap = world_snapshot_create();
      if (!snap) {
          yyjson_doc_free(doc);
          return NULL;
      }

      snap->entity_count  = extract_latest_gauge(root, "entities.count");
      snap->fps           = extract_latest_gauge(root, "performance.fps");
      snap->system_count  = extract_latest_gauge(root, "queries.system_count");

      // frame_time is in seconds from flecs; convert to milliseconds
      double frame_time_s = extract_latest_gauge(root, "performance.frame_time");
      snap->frame_time_ms = frame_time_s * 1000.0;

      yyjson_doc_free(doc);
      return snap;
  }
  ```

  Key decisions:
  - Use `yyjson_is_num()` + `yyjson_get_num()` instead of `yyjson_get_real()` to handle integer-typed values (Open Question #2 from research)
  - Multiply `performance.frame_time` by 1000 to convert seconds to milliseconds for display
  - All null checks in `extract_latest_gauge` prevent crashes on malformed/partial responses
  - `yyjson_doc_free()` releases all parsed memory in one call (snapshot pattern)

  **3. Replace `src/main.c`** with a data pipeline test that exercises HTTP + JSON + data model:

  ```c
  /*
   * cels-debug -- Terminal-based ECS inspector for CELS applications
   * Data pipeline verification (replaced with full TUI in Plan 01-03)
   */
  #include <stdio.h>
  #include <stdlib.h>

  #include "http_client.h"
  #include "json_parser.h"
  #include "data_model.h"

  int main(int argc, char *argv[]) {
      (void)argc;
      (void)argv;

      const char *url = "http://localhost:27750/stats/world";

      printf("cels-debug v0.1.0 -- data pipeline test\n\n");

      // Initialize HTTP client
      CURL *curl = http_client_init();
      if (!curl) {
          fprintf(stderr, "ERROR: Failed to initialize HTTP client\n");
          return 1;
      }

      // Fetch /stats/world
      printf("Fetching %s ...\n", url);
      http_response_t resp = http_get(curl, url);

      connection_state_t conn = connection_state_update(CONN_DISCONNECTED, resp.status);

      if (resp.status == 200) {
          printf("HTTP 200 OK (%zu bytes)\n", resp.body.size);
          printf("Connection: CONNECTED\n\n");

          // Parse JSON into snapshot
          world_snapshot_t *snap = json_parse_world_stats(resp.body.data, resp.body.size);
          if (snap) {
              printf("=== World Stats ===\n");
              printf("  Entities:   %.0f\n", snap->entity_count);
              printf("  FPS:        %.1f\n", snap->fps);
              printf("  Frame time: %.2f ms\n", snap->frame_time_ms);
              printf("  Systems:    %.0f\n", snap->system_count);
              printf("\nData pipeline OK.\n");
              world_snapshot_free(snap);
          } else {
              printf("ERROR: JSON parse failed\n");
          }
      } else if (resp.status == -1) {
          printf("Connection failed (target not running?)\n");
          printf("Connection: %s\n",
                 conn == CONN_DISCONNECTED ? "DISCONNECTED" : "RECONNECTING");
          printf("\nThis is expected if no CELS app is running on port 27750.\n");
          printf("Data pipeline test: HTTP client works, JSON parse not tested.\n");
      } else {
          printf("HTTP %d\n", resp.status);
          printf("Connection: %s\n",
                 conn == CONN_DISCONNECTED ? "DISCONNECTED" : "RECONNECTING");
      }

      http_response_free(&resp);
      http_client_fini(curl);

      return 0;
  }
  ```

  **4. Update `CMakeLists.txt`** -- Add new source files to the `add_executable` call. Change:
  ```cmake
  add_executable(cels-debug
      src/main.c
  )
  ```
  To:
  ```cmake
  add_executable(cels-debug
      src/main.c
      src/http_client.c
      src/json_parser.c
      src/data_model.c
  )
  ```
  </action>
  <verify>
  Build and run the data pipeline test:
  ```bash
  cd /home/cachy/workspaces/libs/cels/build
  cmake .. -DCELS_BUILD_TOOLS=ON -DCELS_DEBUG=ON
  cmake --build . --target cels-debug 2>&1 | tail -10
  ```
  Expected: Clean build, no errors, no warnings.

  Run without a CELS app (expected: graceful failure):
  ```bash
  ./cels-debug
  ```
  Expected output:
  ```
  cels-debug v0.1.0 -- data pipeline test

  Fetching http://localhost:27750/stats/world ...
  Connection failed (target not running?)
  Connection: DISCONNECTED

  This is expected if no CELS app is running on port 27750.
  Data pipeline test: HTTP client works, JSON parse not tested.
  ```
  Exit code 0 (no crash on connection failure).

  If a CELS app IS running with -DCELS_DEBUG=ON:
  ```bash
  ./cels-debug
  ```
  Expected output:
  ```
  cels-debug v0.1.0 -- data pipeline test

  Fetching http://localhost:27750/stats/world ...
  HTTP 200 OK (XXXX bytes)
  Connection: CONNECTED

  === World Stats ===
    Entities:   42
    FPS:        60.0
    Frame time: 16.67 ms
    Systems:    5

  Data pipeline OK.
  ```
  </verify>
  <done>
  The complete data pipeline works end-to-end:
  - http_client.c connects to localhost:27750 with 200ms timeout
  - http_client.c returns status -1 (not crash) when target is down
  - json_parser.c extracts entity_count, fps, frame_time_ms, system_count from /stats/world
  - data_model.c allocates and frees snapshots cleanly
  - connection_state_update transitions correctly
  - cels-debug binary builds with all 6 source files and exits 0
  </done>
</task>

</tasks>

<verification>
1. Build: `cmake --build /home/cachy/workspaces/libs/cels/build --target cels-debug` succeeds with no errors
2. Run without target: `./cels-debug` prints "Connection failed" and exits 0 (no crash, no hang beyond 200ms)
3. Run with target: `./cels-debug` prints entity count, FPS, frame time, system count from live data
4. All headers have include guards
5. No memory leaks in snapshot lifecycle (alloc -> free)
6. Connection state machine: DISCONNECTED on failure from cold start, RECONNECTING on failure from CONNECTED
</verification>

<success_criteria>
- cels-debug builds with http_client.c, json_parser.c, data_model.c linked
- HTTP GET to localhost:27750/stats/world returns response or graceful -1 status
- JSON parser extracts entity_count, fps, frame_time_ms, system_count from real flecs /stats/world response
- Connection state transitions work: DISCONNECTED -> CONNECTED -> RECONNECTING -> CONNECTED
- No crash on connection failure (timeout at 200ms max)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
